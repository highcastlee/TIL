

# Javascript 순열 조합

## 순열(Permutation)
  - 순열 또는 치환은 순서가 부여된 임의의 집합을 다른 순서로 뒤섞는 연산
  - n개 원소에 대한 순열의 수는 n! 이다.

### 반복문 활용 순열 생성
  - 원하는 순열의 길이만큼 값의 자리마다 단순 반복문을 생성하여 중복 배제하여 생성
  - 원본 배열이 n개, 원하는 순열의 길이가 k일 경우, O(n^k)의 시간복잡도를 가지기 때문에 매우 비효율적.

  ```javascript
  const arr = [1, 2, 3, 4]
  const result = []; 
  for(let i=0; i<arr.length; i++){
      for(let j=0; j<arr.length; j++){
          for(let k=0; k<arr.length; k++) {
              // 중복 배제
              if( i === j || j === k || k === i ) continue;
              const current = [ arr[i], arr[j], arr[k] ];
              result.push(current);
          }
      }
  }
  ```

### 배열 및 재귀 활용 순열 생성
  - 배열의 인덱싱을 활용하여 각 순열마다 첫 자리를 fixed 하는 방식으로 n개가 될 때까지 재귀.

  ```javascript
    function getPermutations (arr, n) {
      if (n <= 1) return arr.map(v => [v])
      const result = []
      arr.forEach((fixed, index, origin) => {
        // 해당 index 제외 나머지 모두가 후보
        const rest = [...origin.slice(0, index), ...origin.slice(index + 1)]
        const combinations = getPermutations(rest, n - 1)
        const attach = combinations.map(combi => [fixed, ...combi])
        result.push(...attach)
      })
      return result
    }
  ```




### 백트래킹 활용 순열 생성
  - javascript의 call stack에 대한 개념을 알고 있어야한다.
  - DFS를 이용하여 하위 노드와 인접한 하위노드들을 깊게 탐색한 다음 하나라도 조건에 부합하지 않는다면 다시 상위 노드로 돌아와 다음 하위 노드를 검색하는 방법

<img src="https://blog.kakaocdn.net/dn/xySAt/btqIGmAQHPP/wrhgIionpkG8JQg03ZAGb1/img.png">

  ```javascript
  // 1부터 n까지 숫자 중 길이가 n인 순열 생성
  function solution(n) {
    let permutation = []
    let result = []
    let visited = new Array(n)

    const getPermutations = () => {
      if (permutation.length == n) {
        result.push(permutation.join(' '))
        return
      }
      for (let i = 1; i <= n; ++i) {
        if (visited[i]) {
          continue
        }
        visited[i] = true
        permutation.push(i)
        getPermutations()
        visited[i] = false
        permutation.pop()
      }
    }

    return getPermutations()
    // n = 4 일 때,
    // return [[1,2,3,4],[1,2,4,3],[1,3,2,4] ... [4,3,2,1]]
  } 
  ```



**javascript의 호출 스택(call stack)**
  - 함수의 호출을 저장하는 자료구조
  - 어떤 함수를 호출하면 스택에 쌓고 또 다른 함수를 호출하면 그 다음 스택에 쌓으면서 가장 위에 쌓인 함수를 가장 먼저 처리
  - 현재 어떤 함수가 동작하고있는 지, 그 함수 내에서 어떤 함수가 동작하는 지, 다음에 어떤 함수가 호출되어야하는 지 등을 제어한다.
```javascript
function main(){
  function first() {
    second();
    console.log('첫 번째');
  }
  function second() {
    third();
    console.log('두 번째');
  }
  function third() {
    console.log('세 번째');
  }
  first();
  third();
}
main();
```

<img src="https://cdn.filestackcontent.com/SuD6onjdQMJuiUmfAULQ">


<hr/>

## 조합(Combination)
  - 집합에서 서로 다른 n개의 원소 중에서 순서에 상관없이 r개를 선택하는 것
  - [1, 2, 3] = [3, 2, 1] 처럼 순서가 달라도 같은 하나의 조합으로 취급한다.

### 배열 및 재귀 활용 조합 생성
  - 배열의 인덱싱을 활용하여 각 arr마다 첫 자리를 fixed 하는 방식으로 길이가 n이 될 때까지 재귀.

  ```javascript
    function getPermutations (arr, n) {
      if (n <= 1) return arr.map(v => [v])
      const result = []
      arr.forEach((fixed, index, origin) => {
        // 해당 index 다음 자리부터 후보
        const rest = origin.slice(index + 1)
        const combinations = getPermutations(rest, n - 1)
        const attach = combinations.map(combi => [fixed, ...combi])
        result.push(...attach)
      })
      return result
    }
  ```

### 백트래킹 활용 조합 생성

```javascript
  // 1부터 n까지 숫자 중 길이가 k인 조합 생성
  const result = [];
  const getCombinations = (n, arr, k) => {
  	if(k===0){
      	result.push(arr.join(" "));
      	return;
      }
      //arr가 빈 배열일 때는 0, 아닐 때에는 마지막 원소+1;
      const smallest = arr.length && arr[arr.length-1]+1;
      for(let next=smallest; next<n; next++){
      	arr.push(next);
          arr(n, arr, k-1);
          arr.pop();
      }
  };
```

```javascript
function solution(){
  const source = [1, 2, 3, 4, 5];
  const final = [];
  function combination(source, target, n, r, count) {
    if(r === 0)final.push(target);
    else if(n === 0 || n < r) return;
    else { 
      target.push(source[count]);
      combination(source, Object.assign([], target), n - 1, r - 1, count + 1);
      target.pop();
      combination(source, Object.assign([], target), n - 1, r, count + 1);
    }
  }
  combination(source, [], 3, 2, 0);
  console.log('final', final);
}
```
