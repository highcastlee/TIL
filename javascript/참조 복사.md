
# 참조의 복사

## 얕은 복사(Shallow copy) vs 깊은 복사(Deep copy)
<img src="https://t1.daumcdn.net/cfile/tistory/998EF6445A6DA15538">


### 얕은 복사(Shallow copy)
  - 가장 상위 객체만 새로 생성되고, 내부 객체들은 참조 관계인 경우
  ```javascript
  let user = {
    name = 'john',
    age = 32,
  };
  
  let admin = user;  //shallow copy. 두 변수 모두 같은 주소를 참조한다.

  admin.name = 'park';  //user.name도 'park'을 가리킴
  user.age = 20;     // admin.name도 20을 가리킴
  ```
  ```javascript
  let user = {
    name = 'john',
    age = 32,
    sizes = {
      height: 180,
      weight: 70,
    },
  };

  let admin = { ...user };

  admin.sizes.height = admin.sizes.height + 1; // user.sizes.height 도 181로 바뀌는 얕은 복사 문제

  // 1번 방법 : loop
  let admin = {};
  for (let key in user){
    admin[key] = user[key]
  }

  // =========================================================

  // 2번 방법 : Object 활용
  let admin = Object.assign({},user) // 첫 번째 파라미터에 두 번째 파라미터 객체 중 열거 가능한 속성을 복사해 붙여넣고 대상 객체 반환.

  // =========================================================

  // 3번 방법 : Spread Operator
  let admin = { ...user };  // {user.name, yser.age}

  ```

  - 얕은 복사의 문제점
    - 객체 내 객체가 존재할 경우, 내부 객체의 참조는 동일한 주소를 가리킨다.
    - 깊이가 깊어질수록 추후 문제가 발생할 가능성이 커진다.


### 깊은 복사(Deep copy)
  - 내부 객체까지 모두 새로 생성

  ```javascript
  let user = {
    name = 'john',
    age = 32,
    sizes = {
      height: 180,
      weight: 70,
    },
  };

  // 1번 방법 : loop문
  function copyObj(obj){
    let result = {};
    for (let key in obj){
      // 내부 객체 만나면, 다시 copy 실행
      if (typeof obj[key] === "object") result[key] = copyObj(obj[key]);
      else result[key] = obj[key];
    }
    return result;
  }
  let admin = copyObj(user);

  // =========================================================

  // 2번 방법 : JSON 변환
  // stringify : js object -> string, parse : string -> js object 변환
  let admin = JSON.parse(JSON.stringify(user));

  admin.sizes.height = admin.sizes.height + 1; // user.sizes.height는 180 유지.

  ```


### 추가
  - lodash라는 라이브러리 내 cloneDeep 같은 함수로 진행하기도 한다.