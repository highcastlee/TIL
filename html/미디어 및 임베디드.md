
# 미디어 및 임베디드 요소

## 미디어

### 이미지
  <img src="https://64.media.tumblr.com/7bd42edc2805d5dcbb55103435bf9623/0af33d9108e87fea-2d/s400x600/d66eeea1bb3f5a75249ab055a50aaa65f424016d.png" alt="compare Raster and Vector" width="50%"/>

  - 래스터 이미지
    - JPG(JPEG) : 정지 이미지를 위해 만들어진 손실 압축 방법 표준.
      - 가장 많이 사용되는 포맷
      - 손실 압축 형식이지만, 파일 크기가 작기 때문에 웹에서 널리 쓰임
      - 압축률을 높이면 파일 크기는 작아지지만, 품질은 떨어진다.
      - 주로 사진 이미지 보관/전송에 사용된다.
    - PNG : 비손실 그래픽 파일 포맷
      - 원본 이미지를 보다 정확하게 표현하거나 투명함을 표현할 때 JPG보다 선호된다.
      - 파일 크기가 JPG보다 크다.
    - GIF
      - 무손실 압축을 사용하며, 투명한 것을 표현할 수 있다.
      - 여러 이미지로 구성된 애니메이션이 가능하다.
    - WEBP : 구글이 만든 이미지 포맷
      - 품질, 압축률 등이 훨씬 우수하나 지원 브라우저가 제한적이다.

  - 벡터 이미지
    - SVG : 픽셀 대신 라인과 곡선으로 이루어진 벡터 파일 포맷
      - 이미지 확대 시, 픽셀 깨짐 현상이 없다.
      - 로고나 그래프 같은 flat한 간단한 이미지에 적합하다.
      - 이미지가 아주 복잡하다면, 읽는 속도가 느려지고 파일 크기가 커질 가능성이 있다.
      - XML로 작성되어 텍스트 편집기에서 편집할 수 있다.
      - javascript 등을 사용하여 svg 아이콘의 색상 변경이나 애니메이션 적용을 할 수 있다.


  1. `<img />`
      - src 속성
        - img 요소의 필수 속성으로, 포함하고자하는 이미지의 경로를 지정한다.
        - alt는 이미지의 텍스트 설명이며, 기능적으로 필수는 아니지만 웹 접근성 차원에서 매우 유용하기 때문에 항상 작성하는 것을 권장한다. 네트워크 오류나 기타 여러 이유로 이미지를 표시할 수 없을 때, 이 속성의 값을 대신 보여준다.
        - 이미지를 가져올 수 없을 때
          - onerror 속성에 오류 처리기를 등록했다면, error 이벤트와 함께 처리기를 호출한다.
          - onerror가 발생하는 조건
            1. src 속성이 비었거나 null일 때
            2. src의 URL이 현재 페이지의 URL과 같을 때
            3. 지정한 이미지가 손상되어 불러올 수 없을 때
            4. 이미지의 메타데이터가 손상되어 원본 크기를 알 수 없고, img 속성에도 크기가 지정되어 있지 않을 때
            5. 브라우저가 지원하지 않는 이미지 형식일 때
          - 오류 발생 시, 대체 이미지 출력 방법
            - ```html
              <img src="noimg.jpg" onerror="this.src='대체이미지.jpg'" />
              ```
            -
              ```html
              <script>
                function onErrorImage(_img) {
                  // 에러 발생 시, 해당 img 요소 src 속성에 대체이미지 넣기
                	$(_img).attr('src', "./대체이미지.png");
                }
              </script>
              <img src="./image.jpg" alt="이미지" onerror="onErrorImage(this)"/>
              ```
            
      - srcset
        - 브라우저가 사용할 수 있는 이미지 소스의 후보.
        - 지정한 뷰포트에 따라 다른 이미지를 호출한다.
        - 주로, 뷰포트에 따라 다른 사이즈의 이미지를 보여주기 위한 반응형 이미지에 사용
        - 너비 표기 
          - 너비 서술자(w)
          - 픽셀 밀도 서술자(x)

      - sizes
        - (미디어 조건) + 소스 크기 로 구성되어 있다.
        - 이 때, 미디어 조건은 뷰포트 속성을 의미한다.
        - 주로 반응형 이미지에 사용된다.

      - srcset은 특정 너비마다 다른 이미지를 호출
      - sizes는 특정 너비마다 img의 크기를 변경
      ```html
      <img
        src="image.jpg"
        srcset="images/small.png 300w,
                images/medium.png 450w,
                images/large.png 600w"
        sizes="(min-width: 600px) 600px,
              (min-width: 450px) 450px,
              300px"
      />
      ```


>*래스터 이미지(비트맵)는 픽셀의 세트로 구성되어 실제 사이즈보다 확대해서 보면  도트가 깨져 보인다. <br/> 반면, 벡터는 깨짐이 없지만, 복잡한 이미지를 표현하는데 한계가 있다.

### 반응형 이미지를 구현할 때, 발생할 수 있는 2가지 문제

#### 1. 아트 디렉션 문제(art direction problem)
  - **다양한 레이아웃에서 다른 형태의 이미지를 제공하고자 하는 문제**
    - = 반응형 이미지에서 이미지의 의도가 제대로 전달되도록 기기에 따라 사진의 핵심을 확대해서 보여주거나 하는 방식
    - ex. desktop 레이아웃에서 가로가 긴 이미지를 보여준다면, mobile 레이아웃에서는 세로가 긴 이미지를 보여주는 것이 유리한 상황.


#### 2. 해상도 전환 문제
  1. **큰 화면에서 작은 이미지를 확대해서 보여주면 래스터 이미지의 경우 도트가 깨져 보이는 문제.**

  2. **반대로, 작은 화면에서 굳이 큰 사이즈의 이미지를 표시할 필요가 없음에도 큰 사이즈의 이미지를 사용하여 대역폭을 낭비하는 문제**

  - 벡터 이미지를 사용하면 사이즈도 작고 확대해도 깨지지 않지만, 사진 같은 복잡한 이미지를 벡터 기반으로 만들기 어렵고, 동적으로 이미지를 받아서 출력하거나 기존 래스터 이미지를 사용해야하는 경우 벡터로만 작업하기 어렵다.

#### 문제 해결 방법
  1. **아트 디렉션 해결**
      - picture, source 요소 및 srcset 속성을 이용해 상황에 따라 적절한 소스를 제공한다.

  2. **해상도 전환 문제 해결**
      - 뷰포트 사이즈에 따라 다른 용량의 이미지를 호출한다.
          - srcset 속성 사용
      - 뷰포트 사이즈에 따라 이미지를 다른 사이즈로 출력한다.
          - sizes 속성 사용
          - 도트 깨짐 현상 방지

  - 아래 예시에서, source media로 나뉘는 것은 뷰포트 너비에 따라 크기가 다른 파일을 불러오는 <strong>[아트 디렉션 문제]</strong>해결
  - 각 source의 srcset 내부에서 너비마다 조금씩 다른 형태로 보여주는 것은 <strong>[해상도 전환 문제]</strong> 해결
  - 뷰포트 사이즈에 따라 sizes가 다르게 적용되는 것은 <strong>[해상도 전환 문제]</strong> 해결
  ```html
  <picture>
    <!-- 가로 해상도가 800px 이상일 경우 gatsby-astronaut.png 파일을 800px size로 사용  -->
    <source
      media="(min-width: 800px)"
      srcset="
        /.../69585/gatsby-astronaut.png 200w,
        /.../497c6/gatsby-astronaut.png 400w,
        /.../ee604/gatsby-astronaut.png 800w
      "
      sizes="(max-width: 800px) 100vw, 800px"
    />
    <!-- 그렇지 않으며 (가로 해상도가 800px 미만일 경우) gatsby-astronaut-mobile.png 파일을 사용    -->
    <!-- 가로 해상도 200 ~ 400px일 경우, '497c6/...png' 400w 파일 호출 및 사이즈 100vw 적용-->
    <source
      srcset="
        /.../65e33/gatsby-astronaut-mobile.png 100w,
        /.../69585/gatsby-astronaut-mobile.png 200w,
        /.../497c6/gatsby-astronaut-mobile.png 400w,
        /.../3dd72/gatsby-astronaut-mobile.png 474w
      "
      sizes="(max-width: 400px) 100vw, 400px"
    />
    <!-- source 조건을 모두 만족하지 못할 경우 or picture 요소를 지원하지 않는 하위 호환성을 위해 img 태그는 하단에 존재해야한다.-->
    <img src="default.png" alt="기본이미지" />
  </picture>
  ```


### video
  - 비디오 플레이백을 지원하는 미디어 플레이어를 문서에 삽입
  - video 태그 내 텍스트는 미디어가 제공되지 않을 때 출력됨.
  - autoplay 속성
    - 자동으로 미디어를 재생시켜주는 속성
    - 사운드가 포함되어 있을 경우, 브라우저는 해당 미디어를 자동 재생시키지 않는다.
    - muted 속성을 추가하면 음소거된 상태로 autoplay가 실행된다.
  - controls 속성
    - 음량 조절, 일시정지, 재시작 등의 컨트롤러 제공
  - poster
    - 지정하는 이미지로 썸네일을 제공하는 속성
    - 기본 값은 첫 번째 프레임 값이 제공됨
  ```html
  <video controls width="250">
    <source src="/media/cc0-videos/flower.webm"
            type="video/webm">
    <source src="/media/cc0-videos/flower.mp4"
            type="video/mp4">
    Sorry, your browser doesn't support embedded videos.
  </video>
  ```

### audio
  - 소리 컨텐츠를 추가할 때 사용하는 요소
  - audio 혹은 video 태그 내 source를 여러개 사용하여 멀티미디어 사용 가능
  - audio 태그의 src 속성으로 미디어 적용 가능
  - audio 또한 muted 되지 않으면 autoplay 적용되지 않음
  ```html
  <figure>
    <figcaption>Listen to the T-Rex:</figcaption>
    <audio
        controls
        src="/media/cc0-audio/t-rex-roar.mp3">
            Your browser does not support the
            <code>audio</code> element.
    </audio>
  </figure>
  ```

### canvas
  - 그래픽 캔버스 요소
  - 그림을 그리기 위해서는 javascript 코드가 필요하다.
  - canvas는 접근성 도구에 노출되지 않기 때문에 접근성 웹 사이트나 앱에서는 캔버스 사용을 피해야한다.
  ```html
  <canvas id="canvas" width="300" height="300">
    캔버스의 내용을 설명하는 대체 텍스트
  </canvas>
  ```
  ```javascript
  var canvas = document.getElementById('canvas');
  var ctx = canvas.getContext('2d');
  ctx.fillStyle = 'green';
  ctx.fillRect(10, 10, 100, 100);
  ```

### iframe
  - 중첩 브라우징 맥락을 나타내는 요소
  - 현재 문서 안에 다른 HTML 페이지를 삽입할 때 사용한다.
  - 보안상 이유로 모든 웹사이트를 넣을 수는 없고, 보통 구글맵 등 특정 서비스를 제공할 때 사용
  ```html
  <iframe id="inlineFrameExample"
    title="Inline Frame Example"
    width="300"
    height="200"
    src="https://www.openstreetmap.org/export/embed.html?bbox=-0.004017949104309083%2C51.47612752641776%2C0.00030577182769775396%2C51.478569861898606&layer=mapnik">
  </iframe>
  ```

<br/>
<hr/>

### 생각
  1. **웹 표준을 지키는 반응형 작업**
      - 지금까지 반응형 웹을 제작하면서 srcset, sizes 속성을 한 번도 사용하지 않았다. 이미지 또한 wrapper를 생성하여 img의 width는 100%로 설정한 후, 미디어쿼리에 따라 wrapper width를 조절하는 방식으로 반응형에 대응했는데, 웹 표준과 아트 디렉션 문제라는 새로운 관점을 알게 되었다.
<br/>

  2. **반응형 img sizes는 css 작업으로 빼는 것이 좋지 않을까**
      >처음 sizes 속성을 접했을 때, css 작업 내 미디어쿼리를 이용한 size 대응과 어떤 차이가 있는지 의문이 들었다. 기능적인 측면에서는 반응형 size 대응은 css 작업 내에 속하는 것이 유지 보수하기 유리할 것이라고 생각한다. 왜냐하면, 반응형 작업을 하다보면 단순 width 값 뿐만 아니라, 다른 스타일을 적용해야하는 경우도 있는데, 일부는 css로, size는 DOM의 속성으로 관리하는 것이 오히려 불편할 수 있기 때문이다.

      라고 생각하며 마무리할 뻔했다.
      문서를 조금 더 찾아보니 css나 javascript로 이미지를 처리하는 것에 비해 html 내에서 처리하는 것이 유용한 이유가 명시되어 있었다.
      
      요약하자면, 
      - 브라우저가 페이지를 불러올 때, main parser가 css와 javascript를 load하고 해석하기 전에 이미지를 다운로드하기 시작한다.
      - 즉, css나 javascript로 뷰포트 너비를 감지하고, 이미지를 바꾸는 것은 이미 이미지가 로드된 이후의 작업이 되기 때문에 반응형 이미지 성능 측면에서 나쁘다고 볼 수 있다.
      
      

