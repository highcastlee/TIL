
#### 부동소수점
  - 배정밀도 64비트 부동소수점
    - 부호(1 bit) + 지수 부분(11 bit) + 가수 부분 (52 bit)
    - 십진수인 소수를 이진수로 변환하고 소수점을 1이 나올 때까지 오른쪽 또는 왼쪽으로 옮긴 다음, 소수점 오른쪽에 해당하는 수를 가수부분에 넣게 되는데 이 수가 표현 자리수보다 넘어서게 되면 나머지 부분에서 반올림 처리를 하므로 근사값이 저장되면서 부정확하게 된다.
    - 따라서 0.1 + 0.2의 결괏값이 0.30000000000000004가 나오게 되는 것이다.

---

#### 템플릿 리터럴은 런타임에 일반 문자열로 변환되어 처리된다.

---

#### 변수는 선언, 함수는 정의
-> 변수는 암묵적으로 undefined가 할당되기는 하지만, 직접적인 초기화가 없는 상황이라면 선언이라고 할 수 있다.
-> 함수는 선언과 동시에 함수리터럴이 값으로 할당되기 때문에 정의로 볼 수 있다.

---

#### score 변수가 가리키는 메모리 주소의 값이 어떤 타입이고 어떤 크기인지 어떻게 알 수 있을까?
  -> 컴파일러 혹은 인터프리터는 심벌 테이블이라는 자료구조를 통해 식별자를 키로, 메모리의 주소와 데이터 타입, 스코프 등을 관리한다.
 -> score가 숫자라면, 8바이트 단위로 메모리 공간에 저장된 데이터를 가져온다.
  (ECMAScript에 숫자는 64비트 부동소수점 사용이므로 8바이트씩 사용한다.)

---

#### 데이터 타입이 필요한 이유
1. 값을 저장할 때 메모리 공간의 크기를 확보하기 위함
2. 값을 참조할 때 한 번에 읽어야할 메모리 공간의 크기를 결정하기 위함
3. 2진수로 저장된 메모리 값을 어떻게 해석할지 결정하기 위함

---

#### 변수는 타입을 가지는가?
  -> 정확히 말하면, 값이 타입을 가진다. 따라서, 할당되어 있는 값의 타입에 따라 해당 변수의 타입이 달라진다고 볼 수 있다.

---

#### NaN은 자기 자신과 일치하지 않는 유일한 값
`NaN === NaN`  // false

따라서, NaN 확인은 isNaN 함수를 사용
`isNaN(NaN)` // true
`isNaN(1+undefined)` // true

---

#### +0 과 -0 모두 0과 일치
`0 === -0`  //true

---

#### `Object.is()`로 정확한 비교 결과 반환 (일치 연산자인 === 와 다른 결과가 있다)
`Object.is(-0, +0)` // false
`Object.is(NaN,NaN)` // true

---

#### 삼항 조건 연산자 표현식은 if문과 달리 값으로 평가될 수 있다.

---

#### null의 typeof 체크
```typeof null; // "object"```
자바스크립트의 초기 버전 버그.
값이 null 타입인지 확인할 때는 === 일치 연산자로 확인

---

#### 선언하지 않은 식별자의 typeof
```typeof a  //"undefined"```
선언하지 않은 식별자는 ReferenceError가 아닌 "undefined" 반환

---

#### 음수의 지수연산자
`-5**2`   // SyntaxError
`(-5)**2`  // 25

---

#### 지수 연산자는 이항 연산자 중에서 우선순위가 가장 높다
`2*5**2`  // 50

---

##### 연산자 우선순위
1. ()
2. new (매개변수 있음), ., [], (), ?.
3. new (매개변수 없음)
4. x++, x--
5. !x, +x, -x, ++x, --x, typeof, delete
6. **
7. *, /, %
8. +, -
9. <, <=, >, >=, in, instanceof
10. `==`, `!=`, `===`, `!==`
11. ??(null 병합 연산자)
12. &&
13. ||
14. ? ... : ... (삼항 연산자)
15. =, +=, -= 등 (할당 연산자)
16. ,

- 우선순위를 명확히 외우는 것이 힘들기 때문에 그룹 연산자 ()로 조절하는 것이 권장된다.


---


####  블록문은 하나의 실행 단위로 취급된다.
 
---

#### 블록문은 자체 종결성을 가지기 때문에 세미콜론을 붙이지 않는다.

---

#### 조건문의 조건식은 암묵적으로 불리언 값으로 강제 변환된다.

---


#### 레이블 문 (label statement)
 - 식별자가 붙은 문을 의미한다.(switch문의 case와 default도 레이블 문이다.)
 ```foo: console.log('foo');```

---

#### 중첩 반복문에서 외부 반복문을 탈출하려면 레이블 문을 활용하여 탈출할 수 있다.
```javascript
outer : for(...){
  for(...){
    break outer;
  }
}
```


---

#### 타입 변환이란, 기존 원시 값을 사용해 새로운 원시 값을 생성하는 것이다.


---

#### 명시적 타입 변환 방법
1. 표준 빌트인 생성자 함수를 new 연산자 없이 호출하는 방법
2. 빌트인 메서드를 사용하는 방법
3. 암묵적 타입 변환을 이용하는 방버 




--- 


#### 단축 평가는 표현식을 평가하는 도중에 평가 결과가 확정된 경우 나머지 평가 과정을 생략하는 것을 의미


---

#### null 병합 연산자 ??는 좌항의 피연산자가 null이나 undefined일때만 우항의 피연산자를 사용한다.

` var foo = null ?? 'default'; `

---


