
# Property Attribute

#### 프로퍼티 어트리뷰트(Property Attribute)
  - 프로퍼티 어트리뷰트는 자바스크립트 엔진이 관리하는 내부 상태 값(meta-property)인 내부 슬롯 `[[Value]]`, `[[writable]]`,`[[Enumerable]]`,`[[Configurable]]`이다.
  - 프로퍼티의 상태
    1. value : 프로퍼티의 값
    2. writable : 값의 갱신 가능 여부
    3. enumerable : 열거 가능 여부
    4. configurable : 재정의 가능 여부
  - 직접 접근할 수는 없지만, Object.getOwnPropertyDescriptor 메서드를 사용하여 간접적으로 확인할 수는 있다.


---


#### 데이터 프로퍼티와 접근자 프로퍼티
  - 데이터 프로퍼티
    - 키와 값으로 구성된 일반적인 프로퍼티

  - 접근자 프로퍼티
    - 다른 데이터 프로퍼티의 값을 읽거나 저장할 때 호출되는 접근자 함수로 구성된 프로퍼티


---



#### 객체 변경 방지
  - 자바스크립트는 객체의 변경을 방지하는 다양한 메서드를 제공한다.
  1. 객체 확장 금지
      - 프로퍼티 추가를 금지한다.
      - Object.preventExtensions()

  2. 객체 밀봉
      - 객체 밀봉이란, 프로퍼티 추가 및 삭제, 어트리뷰트 재정의 금지를 의미한다
      - 읽기와 쓰기만 가능
      - Object.seal()

  3. 객체 동결
      - 객체 동결은 읽기만 가능하다.
      - Object.freeze()
  
  - 위 객체 변경 방지들은 직속 프로퍼티에만 영향을 주기 때문에, 중첩 객체에도 영향을 주려면 재귀적으로 변경 방지 메서드를 사용해야한다.



---


# 생성자 함수에 의한 객체 생성


#### Object 생성자 함수
  - 생성자 함수란, new 연산자와 함께 호출하여 객체를 생성하는 함수를 말한다.
  - 생성자 함수에 의해 생성된 객체를 인스턴스라 한다.
  - 빌트인 생성자 함수
    - String, Number, Boolean, Function, Array, Date, RegExp, Promise 등
  

---



#### 객체 리터럴에 의한 객체 생성
  - 문제 : 하나의 객체만 생성하기 때문에 재사용 측면에서 비효율적이다.

---


#### 생성자 함수에 의한 객체 생성
  - 장점 : 인스턴스를 생성하기 위한 템플릿처럼 프로퍼티 구조가 동일한 서로 다른 객체 여러 개를 간편하게 생성할 수 있다.

  - 생성자 함수의 역할
    - 인스턴스를 생성(필수)
    - 생성된 인스턴스를 초기화(선택)


---


#### 생성자 함수의 인스턴스 생성 과정
  1. 생성자 함수로 객체를 생성하면, 암묵적으로 빈 객체가 생성된다.
      - 이 빈 객체는 this에 바인딩된다.
      - 해당 바인딩은 런타임 이전에 실행된다.
  2. 인스턴스 초기화 
      - 생성자 함수에 기술되어 있는 코드가 한 줄씩 실행되어 this에 바인딩 되어 있는 인스턴스를 초기화한다.
  3. 생성자 함수 내부의 처리가 끝나면 this가 암묵적으로 반환된다.
    - 만약, this가 아닌 다른 객체를 임의로 return 한다면, this가 반환되지 못하고 해당 객체가 반환된다.
    - 하지만, return 값이 원시 값이라면, 해당 값을 무시하고 this를 반환한다.
    - **생성자 함수 내 return은 기본 동작을 훼손하기 때문에 사용하지 않도록 한다.**


---



#### 내부 메서드 `[[Call]]`, `[[Construct]]`
  - 함수는 객체이므로, 객체가 가진 내부 슬롯과 내부 메서드를 모두 갖고 있다.
  - 일반 객체와 다르게 함수는 호출할 수 있고, 함수 객체만을 위한 `[[Environment]]` , `[[FormalParameters]]` 등의 내부 슬롯과  `[[Call]]`,  `[[Construct]]` 같은 내부 메서드를 추가로 가지고 있다.
  - 함수가 일반 함수로 호출되면 `[[Call]]`이 호출
  - 함수가 생성자 함수로 호출되면 `[[Construct]]`로 호출
  - `[[Call]]`을 갖는 객체를 callable이라 하는데, 함수 객체는 늘 호출 가능한 callable이어야한다.

  - `[[Construct]]`는 해당 객체가 생성자 함수로서 호출할 수 있으면 가지고 있고, 아니라면 없다.


---


#### contructor와 non-constructor의 구분
  - constructor : 함수 선언문, 함수 표현식, 클래스
  - non-constructor : 메서드 축약 표현, 화살표 함수

  > *메서드 축약 표현 : `add(){}` 와 같은 축약 표현
  
  - 함수 객체가 `[[Call]]`과 `[[Constructor]]`를 모두 갖고 있다면, 
    - new 연산자를 사용할 때는 `[[Constructor]]`가 호출되어 생성자 함수로 동작
    - new 연산자 없이 호출하면 `[[Call]]`을 호출하여 일반 함수로 호출된다.


---


#### 생성자 패턴
  1. new.target
      - new.targer은 this와 유사하게 constructor인 모든 함수 내부에서 암묵적인 지역 변수와 같이 사용되며 메타 프로퍼티라고 부른다.
      - new 연산자 없이 일반 함수로서 호출된 함수 내부의 new.target은 undefined이다.

      ```javascript
      function Circle(radius){
        if(!new.target){
          return new Circle(radius);
        }
        ...
      }
      ```
  
  2. scope-safe constructor
      - this가 Circle과의 프로토타입 연결이 없을 경우
      ```javascript
      function Circle(radius){
        if(!(this instanceof Circle)){
          return new Circle(radius);
        }
        ...
      }
      ```
  
---



#### 빌트인 생성자 함수
  - Object와 Function 생성자 함수는 new 연산자 없이 호출해도 new 연산자를 사용한 것과 동일하게 동작한다.
  - String, Number, Boolean은 new 연산자 없이 호출하면 변환 함수로 동작한다.



---



# 프로토타입(Prototype)

<img src="https://poiemaweb.com/img/object_literal_prototype_chaining.png" width="600px">

#### 명령형 vs 선언형
  - 명령형은 어떻게 구현하는지 기술하는 프로그래밍 기법
  - 선언형은 무엇을 구현하는지 기술하는 프로그래밍 기법


---



#### 객체지향 프로그래밍
  - 독립적 단위인 객체의 집합으로 프로그램을 표현하려는 프로그래밍 패러다임
  - 객체 : 속성을 통해 여러 개의 값을 하나의 단위로 구성한 복합적인 자료구조
  - 객체지향 프로그래밍은 객체의 상태를 나타내는 데이터와 데이터를 조작할 수 있는 동작을 하나의 논리적인 단위로 묶어 생각한다.
    - 상태 데이터는 프로퍼티, 동작은 메서드라 부른다.

---


 #### 상속과 프로토타입
  - 상속(inheritance) : 어떤 객체의 프로퍼티 또는 메서드를 다른 객체가 상속받아 그대로 사용할 수 있는 것을 말하낟.
  - 자바스크립트는 프로토타입으로 상속을 구현하여 불필요한 중복을 제거한다.


---



#### 프로토타입 객체
  - 모든 객체는 하나의 프로토타입을 갖는다
    - `[[Prototype]]`의 값이 null인 객체는 프로토타입이 없다.


---


#### 생성자 객체는 __proto__ 프로퍼티를 소유하지 않는다.
#### 프로토타입 객체인 Object.prototype이 __proto__를 소유하고, 생성자 객체는 해당 접근자 프로퍼티를 상속받아 사용할 수 있다.



---



#### Object 생성자 함수가 생성한 객체는 객체 리터럴에 의해 생성된 객체와 다르다. 중간 처리 과정이 다름.

---


#### 함수 생성자 함수 vs 함수 선언문,함수 표현식
  - Function 생성자 함수로 생성한 함수는 클로져도 안 만들고, 렉시컬 스코프를 만들지도 않는다. 즉, 함수 선언문, 함수 표현식을 평가하여 생성한 함수 객체와 다르다.

  - 하지만, 함수 선언문으로 생성한 함수도 constructor는 Function 이다.


---



#### 프로토타입은 생성자 함수가 생성되는 시점에 더불어 생성된다.
  - prototype과 constructor는 쌍으로 존재한다.
  - 생성된 prototype은 객체이기 때문에 prototype의 prototype은 항상 Object.prototype이다.

---



#### 빌트인 생성자 함수의 프로토타입은 전역 객체가 생성되는 시점에 생성된다.

---



#### 프로토타입 체인이란
  - 객체의 프로퍼티에 접근하려고 할 때, 해당 객체에 접근하려는 프로퍼티가 없다면 `[[Prototype]]` 내부 슬롯의 참조를 따라 자신의 부모 역할을 하는 프로토타입의 프로퍼티를 순차적으로 검색한다. 이를 프로토타입 체인이라 한다.


---


#### Object.create(null)는 Object.prototype을 상속 받지 못한다.
  - Object.create 장점
    - new 연산자가 없이도 객체를 생성할 수 있다.
    - 프로토타입을 지정하면서 객체를 생성할 수 있다.
    - 객체 리터럴에 의해 생성된 객체도 상속받을 수 있다.


---


#### this를 사용하지 않는 메서드는 정적 메서드로 동작할 수 있다.
  - 즉, 인스턴스로 생성하지 않아도 호출할 수 있다.


---


#### for ... in 문과 in 연산자는 대상 객체와 상속 프로토타입의 프로퍼티를 열거
  -  단, in 연산자는 Object.prototype을 포함
  - for ... in 문은 Object.prototype 제외
    - Object.prototype 프로퍼티들의 `[[Enumerable]]`이 false이기 때문
    - for ... in 문은 체인 상 모든 프로토타입 프로퍼티 중 `[[Enumerable]]`이 true인 프로퍼티를 순회하며 열거한다.
    - 키가 Symbol인 프로퍼티는 열거하지 않는다.
  
