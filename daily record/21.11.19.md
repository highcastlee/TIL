
### 렉시컬 스코프가 무엇인가?
  - 함수는 호출되는 시점이 아닌, 함수가 평가되어 정의되는 시점에 상위 스코프가 결정되는데, 이를 렉시컬 스코프라고 한다.


### 프로토타입 상속과 클래스 상속의 차이
  - 프로토타입 상속은 프로토타입 객체의 프로퍼티만 접근할 수 있다.
  - 클래스 상속은 extends, super 의 사용으로 수퍼클래스 함수의 프로퍼티까지 받아서 확장할 수 있다.


### 객체 생성 방법
  - 객체 리터럴, Object 생성자 함수, 생성자 함수, Object.create, 클래스


### strict mode란?
  - 자바스크립트의 문법을 좀 더 엄격히 적용하여 오류를 발생시킬 가능성이 높거나 자바스크립트 엔진의 최적화 작업에 문제를 일으킬 수 있는 코드에 대해 명시적으로 에러를 발생시킨다.
  - 대표적으로 선언되지 않은 변수에 할당했을 때, 에러가 아닌 전역 객체의 프로퍼티로 생성되는 암묵적 전역 등이 있다



### 자바스크립트 객체의 분류
  - 표준 빌트인 객체
    - 전역 객체의 프로퍼티로 존재.
    - js 실행 환경과 상관 없이 사용 가능
  - 호스트 객체
    - ECMAScript 사양에 정의되어 있지 않지만, js 실행 환경에서 추가로 제공하는 객체
  - 사용자 정의 객체
    - 사용자가 직접 정의한 객체


### 래퍼 객체가 무엇인가
  - 문자열, 숫자, 불리언 값에 대해 객체처럼 접근하면 생성되는 임시 객체를 래퍼 객체라고 한다.


### this 바인딩
  - this는 함수의 호출 방식에 따라 결정된다.
  - 일반 함수 호출은 전역 객체
  - 메서드 호출은 메서드를 호출한 객체
  - 생성자 함수 호출(new)은 생성자 함수가 생성한 인스턴스
  - bind, call, apply 간접 호출은 인수로 전달한 객체



### javascript 소스 코드 타입
  - 전역 코드, 함수 코드, eval코드, 모듈 코드


### 전역 코드 평가 과정
  - 전역 실행 컨텍스트 생성
  - 전역 렉시컬 환경 생성
    - 전역 환경 레코드 생성
      - 객체 환경 레코드 생성
        - BindingObject가 window 객체를 가리킨다.
          - 전역 변수 선언 및 함수 정의
          - 이 때, 정의와 동시에 생성된 함수 객체는 프로퍼티를 가진다.
      - 선언적 환경 레코드 생성
        - let, const 식별자
    - this 바인딩
      - 
    - 외부 렉시컬 환경에 대한 참조 결정


### 재귀 함수 실행 과정 설명
  - 첫 번째 함수가 호출되면 해당 함수의 실행 컨텍스트 생성 및 스택에 쌓임
  - 해당 코드 실행 중, 재귀 함수 호출을 만나면, 재귀 함수에 대한 함수 실행 컨텍스트 생성 및 스택에 쌓임
  - 그렇게 쌓이다가 조건을 만나 return이 되면서 상위의 스택부터 이후 코드 실행
  - 최종적으로 처음 호출된 함수가 종료하면서 끝남

### 함수는 함수 객체의 내부 슬롯 `[[Environment]]`에 자신이 정의된 환경 즉, 상위 스코프의 참조를 저장한다.


### 클로저란 무엇인가
  - 외부 함수보다 중첩 함수가 더 오래 유지되는 경우, 중첩 함수는 이미 생명 주기가 종료된 외부 함수의 변수를 참조할 수 있다. 이러한 중첩 함수를 클로저라고 한다.

### 클래스와 생성자 함수의 차이
  - 클래스는 new 연산자가 필수다
  - 클래스는 extends와 super 키워드를 제공한다
  - 클래스는 호이스팅이 발생하지만, TDZ가 있다.
    - 클래스는 블록 레벨 스코프를 가진다.
  - 클래스는 암묵적으로 strict mode가 지정되어 실행되며 해제할 수 없다.
  - 클래스는 모드 프로퍼티 어트리뷰트 `[[Enumerable]]`이 false다.


### 클래스의 인스턴스 생성 과정
  - new 연산자와 함께 호출하면 constructor 내부 코드 실행 전에 빈 객체가 생성

### super
  - super를 호출하면, 수퍼클래스의 constructor가 호출된다.
  - super를 참조하면, 수퍼클래스의 메서드를 호출할 수 있다.


### 화살표 함수의 차이
  - non-constructor이고, 프로토타입을 생성하지 않는다.
  - this 바인딩이 없다
  - 중복된 매개변수 이름을 선언할 수 없다.

### 렉시컬 this
  - 화살표 함수는 this 바인딩을 하지 않으므로 화살표 함수 내부에서 this를 사용하면 상위 스코프의 this를 참조한다.



### 추상화란 무엇인가
  - 사용자에게 중요한 정보만 제공하고, 세부적인 내용은 작성하지 않도록 설계하는 방법
  - 코드 중복 방지 및 재사용성 향상에 도움이 된다.



### 프로토타입 기반 상속 구현
```javascript
function Circle(radius){
  this.radius = radius;
  this.getArea = function() {
    return Math.PI * this.radius ** 2;
  }
}
```

```javascript
function Circle(radius){
  this.radius = radius;
}

Circle.prototype.getArea = function() {
  return Math.PI * this.radius ** 2;
}
```


### 메서드를 정의할 때 정적 메서드와 프로토타입 메서드는 어떻게 구분하나요
  - 정적 메서드는 생성자 함수 객체에 정의되고, 프로토타입 메서드는 생성자 함수의 프로토타입 객체에 정의된다. 



### 내부 슬롯과 내부 메서드는 무엇인가요?
  - 내부 슬롯과 내부 메서드는 자바스크립트 엔진의 구현 알고리즘을 설명하기 위해 ECMAScript 사양에서 사용하는 의사 프로퍼티와 의사 메서드다.
  - 즉, 내부 슬롯과 내부 메서드이 객체의 프로퍼티는 아니다.

### 데이터 프로퍼티와 접근자 프로퍼티
  - 데이터 프로퍼티는 키와 값으로 구성된 일반적인 프로퍼티
  - 접근자 프로퍼티는 다른 데이터 프로퍼티의 값을 읽거나 저장할 때 호출되는 접근자 함수로 구성된 프로퍼티

