# Decode ways
 - [91번](https://leetcode.com/problems/decode-ways/)


### 첫 번째 풀이
  - DFS
  - 0은 앞 숫자와 합쳐서 copy 배열 생성
  - copy 내 앞 뒤 숫자 합이 26 이하인지 아닌지에 따라 합쳐서 dfs 실행
  - subset join한 문자열 값이 s와 같으면 result 케이스 증가
  - subset을 key로 hash에 존재하면 중복 실행 방지

  - 시간초과 발생

  ```javascript
  /**
   * @param {string} s
   * @return {number}
   */
  var numDecodings = function(s) {
      if(+s === 0) return 0
      const copy = s.split("");
      for(let i=0; i<copy.length; i++){
          if(copy.length-1 <= i) break
          if(copy[i+1] == '0'){
              copy[i] += '0';
              copy.splice(i+1,1);
          }
      }

      const hash = {};
      let result = 0;
      function dfs(arr, subset){
          const key = subset.join("/");
          if(hash[key]) return;
          hash[key] = hash[key] ? hash[key]+1 : 1
          if(arr.length === 0 && subset.join("") === s){
              result++;
              return
          }
          for(let i=0; i<arr.length; i++){
              if(arr[i]==='0') continue;
              subset.push(arr[i]);
              dfs([...arr.slice(i+1)], [...subset]);
              subset.pop();                
              if((arr[i] && arr[i+1]) && +(arr[i]+arr[i+1]) <= 26){
                  subset.push(arr[i]+arr[i+1]);
                  dfs([...arr.slice(i+2)], [...subset]);
                  subset.pop();
              }
          }
      }
      dfs(copy, []);
      return result;
  };
  ```