
# 가장 먼 노드


## 그래프
  - [가장 먼 노드](https://programmers.co.kr/learn/courses/30/lessons/49189)

  <img src="https://user-images.githubusercontent.com/62092665/137349043-29ec543e-1455-4ecc-bdc7-45cc091c05ac.png">



### 내 풀이
  - 이동 거리 기록 문제
  - 정점과 간선으로 BFS 실행
  - BFS 실행 중 count를 visted에 기록한다
  - 기록된 visited 중 최대 값을 가진 요소의 개수 구하기

```javascript
function solution(n, edge) {
    let graph = Array.from({length:n+1}, _ => [])
    let visited = Array.from({length:n+1}, _ => 0)
    edge.forEach(arr =>{
        graph[arr[0]].push(arr[1])
        graph[arr[1]].push(arr[0])
    })
    
    let q = []
    q.push([1,1])   // q 요소 = [index, count]
    while(q.length != 0){
        let [index,count] = q.shift()
        if(visited[index]) continue
        visited[index] = count
        for(let i of graph[index]){
            if(visited[i]) continue
            q.push([i,count+1])
        }
    }
    let answer = 0
    visited.forEach(v => {
        if(Math.max(...visited) == v) answer++;
    })
    return answer
}
```


---


### 첨언
  - 여러 index를 잘 구분해서 사용해야하는 문제
  - Object를 이용할 수 있고, 헷갈리지만 않으면 Array의 index로도 할 수 있다.
  - BFS, DFS 실행하면서 count 하는 문제가 많기 때문에 익숙해지도록 연습
