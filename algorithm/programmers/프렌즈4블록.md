
# 카카오 1차 프렌즈4블록
  - [프렌즈4블록](https://programmers.co.kr/learn/courses/30/lessons/17679)



### 내 풀이 
  - 4칸 체크 후, 위치 값 저장
    - 특정 row, col 값의 아래가 'X'이면 row를 증가시키는 방식으로 체크
  - 전체 탐색해서 저장된 위치 'X'로 치환
  - 체크된 위치가 없을 때까지 반복
  - 종료 후, graph 상의 'X' 개수 출력

  - **결론적으로, 치환 후 재배치 논리가 잘못됨**
    - 위에서 체크하는 게 아니라, 그래프의 아래부터 체크해서 'X'이면 위의 값을 가져오는 방식이 더 맞을 듯

```javascript
function solution(m, n, board) {
    function getBlocks(graph, row, col){
        const word = graph[row][col]
        const result = [[row,col]]
        let [second, third, fourth] = [null, null, null]
        while(++row<m){
            if(third && fourth) break
            if(graph[row][col] !== 'X' && graph[row][col] !== word) break
            if(graph[row][col+1] !== 'X' && graph[row][col+1] !== word) break
            if(!third && graph[row][col] == word) {
                third = [row,col]
                result.push(third)
            }
            if(!fourth && graph[row][col+1] == word){
                fourth = [row,col+1]
                result.push(fourth)
            }
        }
        return result
    }
    
    let answer = 0;
    let locations = [];
    board = board.map(str=>str.split(""))
    do{
        locations = []
        for(let r=0; r<m-1;r++){
            for(let c=0;c<n-1;c++){
                if(board[r][c] !== 'X'){
                    let result = getBlocks(board,r,c)
                    if(result.length == 4) locations.push(result)
                }
            }
        }
        if(locations.length == 0) break
        locations.forEach(location => {
            location.forEach(([row,col])=>{
                board[row][col] = 'X'
            })
        })
    }while(locations.length>0)
    return answer;
}
```


### 다른 풀이
```javascript
function solution(m, n, board) {
    board = board.map(v => v.split(''));

    while (true) {
        let founded = [];

        // 찾기
        for (let i = 1; i < m; i++) {
            for (let j = 1; j < n; j++) {
                if (board[i][j] && board[i][j] === board[i][j - 1] && board[i][j] === board[i - 1][j - 1] && board[i][j] === board[i - 1][j]) {
                    founded.push([i, j]);
                }
            }
        }

        if (! founded.length) return [].concat(...board).filter(v => ! v).length;

        // 부수기
        founded.forEach(a => {
            board[a[0]][a[1]] = 0;
            board[a[0]][a[1] - 1] = 0;
            board[a[0] - 1][a[1] - 1] = 0;
            board[a[0] - 1][a[1]] = 0;
        });

        // 재정렬
        for (let i = m - 1; i > 0; i--) {
            if (! board[i].some(v => ! v)) continue;

            for (let j = 0; j < n; j++) {
                for (let k = i - 1; k >= 0 && ! board[i][j]; k--) {
                    if (board[k][j]) {
                        board[i][j] = board[k][j];
                        board[k][j] = 0;
                        break;
                    }
                }
            }
        }
    }
}
```