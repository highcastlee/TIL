# 매칭 점수
 - []()

### 풀이
 - 정규표현식 및 구현
 ```javascript
    function solution (word, pages) {
      word = word.toLowerCase();
      const REGEX_WORD = /[\d|\W]/;
      const REGEX_URL = /<a href="https:\S*"/gi;
      const META_URL = 'meta property';
      const pageInfo = new Map();
    
      pages.forEach((page, idx) => {
        const pageArr = page.split('\n');
        const urlIdx = pageArr.findIndex(el => el.includes(META_URL));
        const pageURL = pageArr[urlIdx].match(/"https:\S*"/gi)[0];
        const bodyStart = pageArr.findIndex(el => el.includes("<body>"));
        const bodyEnd = pageArr.findIndex(el => el.includes("</body>"));
        const body = pageArr.slice(bodyStart+1, bodyEnd);
        const point = body.flatMap(str => str.toLowerCase().split(REGEX_WORD)).filter(e => e === word).length;
        const outLinks = body.flatMap(str => str.match(REGEX_URL)).filter(e => e).map(e => e.substr(8, e.length));
        
        pageInfo.set(pageURL, { point, outLinks, idx, matchPoint : 0 });
      });
    
      for(const [key, value] of pageInfo) {
        const linkPoint = value.point / value.outLinks.length;
        
        for(const link of value.outLinks) {
          if(pageInfo.has(link)) {
            const origin = pageInfo.get(link);
            const calculatedPoint = origin.matchPoint 
            	? origin.matchPoint + linkPoint
            	: origin.point + linkPoint;
            pageInfo.set(link, { ...origin, matchPoint: calculatedPoint });
          }
        }
      }
    
      const answer = [];
    
      for(const [key, value] of pageInfo) {
        const { point, idx, matchPoint } = value;
        const finalPoint = matchPoint ? matchPoint : point;
        answer.push([ idx, finalPoint ]);
      };
    
      answer.sort((a, b) => a[1] === b[1] ? a[0] - b[0] : b[1] - a[1]);
    
      return answer[0][0];
    }
 ```

### 실패 풀이
  - 정규표현식, 문자열 찾기, 해시 등으로 정보 저장하여 값 계산
  - href와 url를 찾아서 해당하는 값 계산하기

  ```javascript
  function solution(word, pages) {
      var answer = new Array(pages.length).fill(0);
      const hash = {};
      let defaultWord = word.toLowerCase();
      pages.forEach((p,index)=>{
          const page = p.toLowerCase();

          let defaultScore = page.match(new RegExp(`(${defaultWord})+`,'g')).filter(v=>v===defaultWord).length;
          let url = '';
          page.split("\n").forEach(str=>{
              const line = str.split(" ");
              if(line.includes('property="og:url"')){
                  url = line[line.length-1].substring(17,line[line.length-1].length-3);
                  if(!hash[url]) hash[url] = {id: index, default:defaultScore, linkScore:0, link:0, href:[]};
                  else {
                      hash[url].id = index;
                      hash[url].default = defaultScore;
                  }
              }
              let matched = str.match(/href="/,'g');
              if(matched) {
                  let idx = matched.index;
                  let href = '';
                  for(let i=idx+14; i<str.length; i++){
                      if(str[i]==='"') break
                      href += str[i];
                  }
                  hash[url].link += 1;
                  if(hash[href]) hash[href].href.push(url);
                  else hash[href] = {default:0, linkScore:0, link:0, href:[url]}
              }
          })
      })
      for(const [key,value] of Object.entries(hash)){
          if(value.id===undefined) continue;
          value.href.forEach(href=>{
              value.linkScore += hash[href].default/hash[href].link;
          });
          answer[value.id] += value.default+value.linkScore
      }
      let max = Math.max(...answer);
      return answer.indexOf(max);
  }
  ```