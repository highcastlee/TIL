# 표 편집
 - [표 편집](https://programmers.co.kr/learn/courses/30/lessons/81303#)


### resolving

```javascript
function solution(n, k, cmd) {
    let answer = new Array(n).fill('O');
    function Node(val,prev,next){
        this.val = val===undefined ? null : val;
        this.prev = prev===undefined ? null : prev;
        this.next = next===undefined ? null : next;
    }
    let head = new Node(0);
    let current = head;
    const arr = new Array(n-1).fill(0).map((_,i)=>i+1);
    
    arr.forEach(num=>{
        current.next = new Node(num,current);
        current = current.next;
    });
    current = head;
    const record = [];
    while(current.val < k && current.val < n) current = current.next;
    cmd.forEach(str=>{
        const [command, count] = str.split(" ");
        if(command === 'D'){
            for(let i=0; i<count; i++) current = current.next;
        }else if(command === 'U'){
            for(let i=0; i<count; i++) current = current.prev;      
        }else if(command === 'C'){
            record.push(current);
            if(current.prev) current.prev.next = current.next;
            if(current.next) current.next.prev = current.prev;
            
            if(current.next) current = current.next;
            else current = current.prev;
        }else if(command === 'Z'){
            let node = record.pop();
            if(node.prev) node.prev.next = node;
            if(node.next) node.next.prev = node;
        }
    });
    
    record.forEach(deletedNode=>{
        answer[deletedNode.val] = 'X';
    })
    return answer.join("");
}
```

### 정식 풀이
  - **연결리스트**
  - 연결리스트를 사용하면, 보다 간단하게 제거하고 복귀시킬 수 있다.
    - 구현 알고리즘 문제에서도 자료구조 아이디어를 떠올리기

```javascript
function solution(n, k, cmd) {
    function Node(id, prev, next){
        this.val = id;
        this.prev = prev ? prev : null;
        this.next = next ? next : null;
    };
    const deleted = [];
    let node = new Node(0);
    let current = node;
    let head = node;
    
    for(let i=1; i<n; i++){
        node.next = new Node(i, node);
        node = node.next;
        
        if(i===k) current = node;
    }
    
    
    const commands = cmd.map(v=>{
        const arr = v.split(" ");
        return [arr[0], arr[1] ? arr[1] : 0]
    });
    
    for(let [command, time] of commands){
        if(command === 'U'){
            while(time && current.prev){
                time--;
                current = current.prev;
            }
        }
        if(command === 'D'){
            while(time && current.next){
                time--;
                current = current.next;
            }
        }
        
        if(command === 'C'){
            deleted.push(current);
            const prev = current.prev;
            const next = current.next;
            if(prev && next){
                prev.next = current.next;
                next.prev = current.prev;
                current = next;
            }
            else if(prev){
                prev.next = null;
                current = prev;
            }
            else if(next){
                next.prev = null;
                current = next;
            }
        }
        
        if(command === 'Z'){
            const node = deleted.pop();
            if(node.prev){
                node.prev.next = node;
            }
            if(node.next){
                node.next.prev = node;
            }
        }
    }    
    const answer = new Array(n).fill('O');
    deleted.forEach(v=>{answer[v.val]='X'});
    
    return answer.join("");
    
}
```

### 효율성 통과 못한 풀이
  - 정확성 : 통과
  - 효율성 : 시간초과

  - 전체 n개의 index를 가진 hash를 만들어 {check, deleted} 기록
  - index에 해당하는 데이터를 지울 필요 없이 check와 deleted로 판단
  - 삭제된 index를 가리키는 deleted에 삭제 발생할 때마다 push, 'Z' 실행 시 pop()을 실행
  
  - cmd의 원소 개수가 20만이고, n이 100만이므로 효율성 통과를 위해서는 O(n^2)이 안 되도록 알고리즘을 짜야한다.

  ```javascript
  function solution(n, k, cmd) {
      const list = {};
      const deleted = [];
      let currentIndex = k;

      for(let i=0; i<n; i++) list[i] = {check:false, deleted: false};
      list[currentIndex].check = true;

      const commands = cmd.map(s=>{
          const arr = s.split(" ");
          arr[1] = arr[1] ? +arr[1] : 0;
          return arr;
      });

      for(const [direction, count] of commands){        
          if(direction === 'C'){
              deleted.push(currentIndex);
              list[currentIndex].check = false;
              list[currentIndex].deleted = true;
              let copyIndex = currentIndex+1;
              while(copyIndex < n && list[copyIndex].deleted) copyIndex++;
              if(!list[copyIndex] || list[copyIndex].deleted){
                  copyIndex = currentIndex;
                  while(copyIndex>=0 && list[copyIndex].deleted) copyIndex--;
              } 
              currentIndex = copyIndex;
              list[currentIndex].check = true;
          }

          if(direction === 'Z'){
              const deletedIndex = deleted.pop();
              list[deletedIndex].deleted = false;
          }

          if(direction === 'D'|| direction === 'U'){
              list[currentIndex].check = false;
              let time = count;
              while(time){
                  currentIndex = direction === 'U' ? currentIndex-1 : currentIndex + 1;
                  if(list[currentIndex].deleted) continue;
                  time--;
              }
              list[currentIndex].check = true;
          }
      }
      return Object.values(list).map(data=>data.deleted ? 'X' : 'O').join("");
  }
  ```


