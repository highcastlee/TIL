# 표 편집
 - [표 편집]()


### 정식 풀이
  - **연결리스트**
  - 연결리스트를 사용하면, 보다 간단하게 제거하고 복귀시킬 수 있다.
    - 구현 알고리즘 문제에서도 자료구조 아이디어를 떠올리기

```javascript
function solution(n, k, cmd) {
    function Node(id, prev, next){
        this.val = id;
        this.prev = prev ? prev : null;
        this.next = next ? next : null;
    };
    const deleted = [];
    let node = new Node(0);
    let current = node;
    let head = node;
    
    for(let i=1; i<n; i++){
        node.next = new Node(i, node);
        node = node.next;
        
        if(i===k) current = node;
    }
    
    
    const commands = cmd.map(v=>{
        const arr = v.split(" ");
        return [arr[0], arr[1] ? arr[1] : 0]
    });
    
    for(let [command, time] of commands){
        if(command === 'U'){
            while(time && current.prev){
                time--;
                current = current.prev;
            }
        }
        if(command === 'D'){
            while(time && current.next){
                time--;
                current = current.next;
            }
        }
        
        if(command === 'C'){
            deleted.push(current);
            const prev = current.prev;
            const next = current.next;
            if(prev && next){
                prev.next = current.next;
                next.prev = current.prev;
                current = next;
            }
            else if(prev){
                prev.next = null;
                current = prev;
            }
            else if(next){
                next.prev = null;
                current = next;
            }
        }
        
        if(command === 'Z'){
            const node = deleted.pop();
            if(node.prev){
                node.prev.next = node;
            }
            if(node.next){
                node.next.prev = node;
            }
        }
    }
    const result = [];
    
    while(head){
        result.push(head.val);
        head = head.next;
    }
    
    const answer = new Array(n).fill('O');
    deleted.forEach(v=>{answer[v.val]='X'});
    
    return answer.join("");
    
}
```

### 효율성 통과 못한 풀이
  - 정확성 : 통과
  - 효율성 : 시간초과

  - 전체 n개의 index를 가진 hash를 만들어 {check, deleted} 기록
  - index에 해당하는 데이터를 지울 필요 없이 check와 deleted로 판단
  - 삭제된 index를 가리키는 deleted에 삭제 발생할 때마다 push, 'Z' 실행 시 pop()을 실행
  
  - cmd의 원소 개수가 20만이고, n이 100만이므로 효율성 통과를 위해서는 O(n^2)이 안 되도록 알고리즘을 짜야한다.

  ```javascript
  function solution(n, k, cmd) {
      const list = {};
      const deleted = [];
      let currentIndex = k;

      for(let i=0; i<n; i++) list[i] = {check:false, deleted: false};
      list[currentIndex].check = true;

      const commands = cmd.map(s=>{
          const arr = s.split(" ");
          arr[1] = arr[1] ? +arr[1] : 0;
          return arr;
      });

      for(const [direction, count] of commands){        
          if(direction === 'C'){
              deleted.push(currentIndex);
              list[currentIndex].check = false;
              list[currentIndex].deleted = true;
              let copyIndex = currentIndex+1;
              while(copyIndex < n && list[copyIndex].deleted) copyIndex++;
              if(!list[copyIndex] || list[copyIndex].deleted){
                  copyIndex = currentIndex;
                  while(copyIndex>=0 && list[copyIndex].deleted) copyIndex--;
              } 
              currentIndex = copyIndex;
              list[currentIndex].check = true;
          }

          if(direction === 'Z'){
              const deletedIndex = deleted.pop();
              list[deletedIndex].deleted = false;
          }

          if(direction === 'D'|| direction === 'U'){
              list[currentIndex].check = false;
              let time = count;
              while(time){
                  currentIndex = direction === 'U' ? currentIndex-1 : currentIndex + 1;
                  if(list[currentIndex].deleted) continue;
                  time--;
              }
              list[currentIndex].check = true;
          }
      }
      return Object.values(list).map(data=>data.deleted ? 'X' : 'O').join("");
  }
  ```


