
# 베스트앨범
  - [베스트앨범](https://programmers.co.kr/learn/courses/30/lessons/42579?language=javascript#)


### 풀이
  - hash = { 장르 : { 재생 수 : [ ...고유번호 ], ... }, ... }
  - 장르별 재생 수의 합이 큰 장르부터.
  - 재생 수가 큰 것부터.
  - 고유 번호가 작은 것부터.
  - 장르당 최대 2개까지 수록

  ```javascript
  function solution(genres, plays) {
    var answer = [];
    const hash = {};
    for(let i=0; i<genres.length; i++){
        if(hash[genres[i]]){
            if(hash[genres[i]][plays[i]]) hash[genres[i]][plays[i]].push(i);
            else hash[genres[i]][plays[i]] = [i];
            hash[genres[i]].sum += plays[i];
        }else{
            hash[genres[i]] = {sum : plays[i]}
            hash[genres[i]][plays[i]] = [i];
        }
    }
    // 재생 수 큰 것부터 정렬
    const orderedHash = Object.entries(hash).sort((a,b)=>b[1].sum - a[1].sum);

    // 장르별 수록 개수 체크를 위한 객체
    const countHash = {}

    for(let [key,subObj] of orderedHash){
        delete subObj.sum;
        const orderedSub = Object.entries(subObj).sort((a,b)=>+b[0] - +a[0]);
        // 장르별 2개까지이므로 재생 횟수도 최대 2번까지만 접근
        for(let i=0; i<2; i++){
            if(!orderedSub[i]||orderedSub[i].length === 0) break
            const arr = orderedSub[i][1].sort((a,b)=>a-b)
            // 같은 재생 횟수 내에서도 최대 2번까지만 접근
            for(let j=0; j<2; j++){
                if(countHash[key] > 1) break
                if(arr[j]===0 || arr[j]) {
                    answer.push(arr[j])
                    countHash[key] = countHash[key] ? countHash[key]+1 : 1;
                }
            }
        }
    }
    return answer;
  }
  ```



### 다른 풀이
  - dic = {장르 : 재생 횟수 합}
  - dupDic = {장르 : 카운트 횟수}

  - 입력된 배열을 정렬하며 필터링
    1. {genre : "classic", count: 500, index: 0} 형식으로 변환
    2. 정렬
        - 장르가 다르면, dic의 재생 횟수 기준으로 내림차순 정렬
        - 장르 같고, 재생 횟수가 다르면, 재생 횟수 기준 내림차순 정렬
        - 둘 다 같으면, 고유 번호(index) 기준 오름차순 정렬
    3. 필터링
        - 정렬된 객체 배열의 dupDic[장르]의 값이 2 미만인 값만 필터
        - return true 하기 전, dupDic[장르] 값 + 1
    4. 필터링된 배열의 고유번호 index만 반환

  ```javascript
  function solution(genres, plays) {
    const dic = {};
    genres.forEach((t,i)=> {
        dic[t] = dic[t] ?  dic[t] + plays[i] :plays[i];        
    });

    const dupDic = {};
    return genres          
          .map((t,i)=> ({genre : t, count:plays[i] , index:i}))
          .sort((a,b)=>{               
               if(a.genre !== b.genre) return dic[b.genre] - dic[a.genre];
               if(a.count !== b.count) return b.count - a.count;
               return a.index - b.index;
           })
           .filter(t=>  {
               if(dupDic[t.genre] >= 2) return false;
               dupDic[t.genre] = dupDic[t.genre] ? dupDic[t.genre]+ 1 : 1;
               return true;
            })
           .map(t=> t.index);    
  }
  ```