# 양과 늑대
 - [양과 늑대](https://programmers.co.kr/learn/courses/30/lessons/92343)


### 풀이
  - DFS
  - 모든 접근 가능한 케이스를 탐색하여 answer 최대값 갱신
  - nextNode로 이동할 때, 해당 다음 이동 케이스인 accessible에 nextNode의 자식 노드들을 누적하여 기록
  - **모두 방문했을 때가 아니라, 지속적으로 answer를 갱신한다**


  ```javascript
  function solution(info, edges) {
      let answer = 0;
      const hash = {};
      edges.forEach(([start,end])=>{
          hash[start] ? hash[start].push(end) : hash[start] = [end];
      });
      const visited = new Array(info.length).fill(false);
      const countSum = [0,0];

      function getPermutations(node, accessible, visited, sum){
          sum[info[node]]+=1;
          visited[node] = true;
          if(sum[0] <= sum[1]) return;
          answer = Math.max(answer, sum[0]);

          for(let i=0; i<accessible.length; i++){
              const nextNode = accessible[i]; 
              if(visited[nextNode]) continue;

              let nextAccess = [...accessible];
              nextAccess.splice(i,1);
              if(hash[nextNode]) nextAccess = nextAccess.concat(...hash[nextNode]);

              getPermutations(nextNode, [...nextAccess], [...visited], [...sum]);
          }
      }
      getPermutations(0, [...hash[0]], visited, [...countSum]);
      return answer;
  }
  ```