# 경주로 건설
 - [경주로 건설](https://programmers.co.kr/learn/courses/30/lessons/67259)


### 풀이
  - DFS
  - 경로 탐색하며, 방향에 따른 price 누적 기록
  - 기록된 price보다 큰 값의 dfs는 continue 처리하여 중지
  - 최종지에 도착하는 dfs중 최소인 값을 answer에 저장
  - answer 반환

  ```javascript
  function solution(board) {
      let answer = Infinity;
      let len = board.length;    
      const dr = [0,1,0,-1];
      const dc = [1,0,-1,0];
      const [right, down, left, up] = [0,1,2,3];
      const visited = new Array(len).fill(0).map(_=>new Array(len).fill(false));
      visited[0][0] = true;
      const priceGraph = new Array(len).fill(0).map(_=>new Array(len).fill(Infinity));

      function dfs(graph, row, col, visited, priceGraph, dir){
          visited[row][col] = true;
          if(row === len-1 && col === len -1){
              answer = Math.min(answer, priceGraph[row][col]);
              return
          }
          for(let i=0; i<4; i++){
              const nr = row + dr[i];
              const nc = col + dc[i];
              if(nr<0||nc<0||nr>=len||nc>=len||visited[nr][nc]||graph[nr][nc]) continue;
              let addPrice = i===dir ? 100 : 600;
              if(priceGraph[nr][nc] < priceGraph[row][col]+addPrice) continue
              priceGraph[nr][nc] = priceGraph[row][col]+addPrice;
              dfs(graph, nr, nc, visited.map(v=>[...v]), priceGraph, i);
          }
      }    
      if(board[1][0]===0) {
          priceGraph[1][0] = 100;
          dfs([...board], 1, 0, visited.map(v=>[...v]), priceGraph.map(v=>[...v]), down);
          priceGraph[1][0] = 0;
      }
      if(board[0][1]===0){
          priceGraph[0][1] = 100;
          dfs([...board], 0, 1, visited.map(v=>[...v]), priceGraph.map(v=>[...v]), right);
          priceGraph[0][1] = 0;
      }

      return answer;
  }
  ```