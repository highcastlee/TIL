# 파괴되지 않은 건물
 - [파괴되지 않은 건물](https://programmers.co.kr/learn/courses/30/lessons/92344)


### 풀이
  - 누적 합(이차원)
  - 특정 이차원 구간에 degree의 값을 계산할 경우, 이차원 누적 활용으로 효율성 증가
    - [[3,0,0,-3],[0,0,0,0],[-3,0,0,3]]을 오른쪽 누적, 아래 누적하면 [[3,3,3,0],[3,3,3,0],[0,0,0,0]]이 되어 해당 구간에만 값을 더할 수 있게 된다.
    - 이를 활용하여, 누적 값을 표시할 graph를 board보다 크기가 1만큼 큰 이차원 배열을 만들어서 누적 시작부분과 끝 부분에 degree를 누적 기록한다.
  
    - skill을 돌 때마다 배열을 반복할 필요 없이, 각 위치에 degree 값만 기록한 후, skill 반복 종료 후 상하좌우 누적 실행.
    - 누적 값을 board와 합쳐서 양 끝 행과 열을 지우면 원하는 그래프 값을 얻을 수 있다.
  - 각 row에서 0보다 큰 값의 개수를 누적 반환


  ```javascript
  function solution(board, skill) {
      var answer = 0;
      const copyBoard = board.map(b=>[...b]);
      const graph = new Array(board.length+1).fill(0).map(_=>new Array(board[0].length+1).fill(0));

      skill.forEach(([type,r1,c1,r2,c2,degree])=>{
          let score = type === 1 ? -degree : degree
          graph[r1][c1] += score;
          graph[r1][c2+1] += -score;
          graph[r2+1][c1] += -score;
          graph[r2+1][c2+1] += score;
      });
      // 오른쪽 누적합
      for(let i=0; i<graph.length; i++){
          for(let j=1; j<graph[0].length; j++){
              graph[i][j] += graph[i][j-1];
          }
      }
      // 아래 누적합
      for(let c=0; c<graph[0].length; c++){
          for(let r=1; r<graph.length; r++){
              graph[r][c] += graph[r-1][c];
          }
      }
      // 누적값 board에 합침
      for(let i=0; i<graph.length-1; i++){
          for(let j=0; j<graph[0].length-1; j++){
              graph[i][j] += board[i][j];
          }
      }
      graph.pop();
      graph.forEach(row=>{
          row.pop();
          answer += row.filter(v=>v>0).length;
      });
      return answer;
  }
  ```