# 아이템 줍기
 - [아이템 줍기](https://programmers.co.kr/learn/courses/30/lessons/87694)


### 풀이
  - 사각형 외곽 모서리만 구해서 두 점사이 최단 거리 구하기
  - **핵심**
    - 내부 빈 사각형이 발생할 경우 모두 사각형으로 채워서 외곽만 구해야한다.
    - 사각형은 1로 빈 공간은 0으로 변경 -> 전체 사각형 바깥 공간을 2로 변경 -> 0인 값은 내부 빈 공간이므로 사각형처럼 1로 변경
    - 위 절차를 따르면, 값이 1인 큰 도형과 배경 2만 남게된다.
    - 값이 1인 도형에서 상하좌우,대각이 모두 1이면 사각형 테두리가 아닌 내부 좌표이다.
      - **단, ㄷ자 형처럼 주변 좌표가 모두 1이지만 테두리인 경우가 있다. 따라서, 전체 그래프와 사각형을 2배로 만들어 공간이 발생하도록 해야한다.**
    - 내부 좌표를 배경과 같은 2로 만들면, 도형의 테두리만 1로 남은 그래프가 생성된다.
    - 문제에 주어진 좌표를 bfs하여 최단거리를 구하고 반환한다.


  ```javascript
  // 그래프 내 start 지점에서 end 지점까지의 최단 거리 반환
  function getMinRoute(graph, startRow, startCol, endRow, endCol){
      const visited = graph.map((row)=>[...row].fill(0));
      const dr = [0,0,1,-1];
      const dc = [1,-1,0,0];
      const q = [[startRow,startCol]];
      visited[startRow][startCol] = 1;
      while(q.length){
          const [cr,cc] = q.shift();
          for(let i=0; i<4; i++){
              const nr = cr+dr[i];
              const nc = cc+dc[i];
              if(nr<0||nc<0||nr>=graph.length||nc>=graph[0].length||visited[nr][nc]||graph[nr][nc] !== 1){
                  continue;
              }
              visited[nr][nc] = visited[cr][cc]+1;
              q.push([nr,nc]);
              if(nr==endRow && nc === endCol){
                  return visited[endRow][endCol]-1;
              }
          }
      }
      return visited[endRow][endCol]-1;
  }

  // passNum 제외 targetNum로 변환하기
  function bfs(graph, row, col, passNum, targetNum){
      const q = [[row,col]];
      const dr = [0,0,1,-1];
      const dc = [1,-1,0,0];
      graph[row][col] = targetNum
      while(q.length){
          const [cr, cc] = q.shift();
          for(let i=0; i<4; i++){
              const nr = cr+dr[i];
              const nc = cc+dc[i];
              if(nr<0||nc<0||nr>=graph.length||nc>=graph[0].length||passNum.includes(graph[nr][nc])){
                  continue;
              }
              q.push([nr,nc]);
              graph[nr][nc] = targetNum
          }
      }
      return graph
  }


  function solution(rectangle, characterX, characterY, itemX, itemY) {    
      var answer = 0;
      let maxRow = -1, maxCol=-1, minRow=51*2, minCol=51*2;

      // 좌표 값 기준으로 graph 생성
      // ㄷ자 좌표 겹치는 현상으로 그래프를 두 배로 만들어 진행한다.
      rectangle.map(arr=>arr.map(v=>v*2)).forEach(([lx,ly,rx,ry])=>{
          maxRow = Math.max(maxRow,ry);
          maxCol = Math.max(maxCol,rx);
          minRow = Math.min(minRow,ly);
          minCol = Math.min(minCol,lx);
      });

      let graph = new Array(maxRow+2).fill(0).map(()=>new Array(maxCol+2).fill(0));

      // 1) 사각형 좌표 전체 1로 체크
      rectangle.map(arr=>arr.map(v=>v*2)).forEach(([lx,ly,rx,ry])=>{
        for(let r=ly; r<=ry; r++){
            for(let c=lx; c<=rx; c++){
                graph[r][c] = 1;
            }
        }
      });

      // 2) 그래프 배경 모두 2로
      const visited = graph.map((row)=>[...row].fill(false));
      graph = bfs(graph, 0, 0, [1,2], 2);

      // 3) 내부 0 찾아서 모두 1로 (2는 배경이므로 0만 내부 빈 공간이다)
      for(let r=0; r<graph.length; r++){
          for(let c=0; c<graph[0].length; c++){
              if(graph[r][c] === 0){
                  graph = bfs(graph, r,c, [1,2], 1)    
              }
          }
      }

      // 4) 대각 포함 주변이 1로 둘러쌓인 값은 테두리가 아니므로 2로 변경
      // 모서리만 1인 그래프 생성
      const newGraph = graph.map((row)=>[...row]);
      for(let r=0; r<graph.length; r++){
          for(let c=0; c<graph[0].length; c++){
              if(graph[r][c] === 1 
                 && graph[r+1][c] === 1
                 && graph[r][c+1] === 1
                 && graph[r-1][c] === 1
                 && graph[r][c-1] === 1
                 && graph[r+1][c+1] === 1
                 && graph[r+1][c-1] === 1
                 && graph[r-1][c+1] === 1
                 && graph[r-1][c-1] === 1
                ){
                  newGraph[r][c] = 2;
              }
          }
      }

      // 5) 모서리인 1 값을 따라 bfs로 최단거리 찾기
      // 그래프를 두 배로 만들었으므로 개수 절반 반환
      return getMinRoute(newGraph, characterY*2,characterX*2, itemY*2, itemX*2)/2;    
  }
  ```