# 기둥과 보 설치
 - [기둥과 보 설치](https://programmers.co.kr/learn/courses/30/lessons/60061#)


### 실패 풀이
  - 구현(시뮬레이션)
  - 임의 삭제 후, 주변 기둥 or 보의 존재 조건 체크
  - 특정 조건이 아닌, 기둥, 보 모두 전수 체크하는 방식으로 수정 필요


  ```javascript
  function solution(n, build_frame) {
      var answer = [];
      // 0 빈 곳, 1 : 기둥, 2 : 보
      function checkBo(graph, row, col){
          if(row === n) return false
          if((row < n && graph[row+1][col] === 1) || (col < n && graph[row+1][col+1] === 1)) return true
          if(col === n || col === 0) return false
          if(col > 0 && col < n){
              if(graph[row][col+1] === 2 && graph[row][col-1] === 2) return true
              else false
          }
          return false
      }
      function checkGidoong(graph, row, col){
          if(row===n) return true
          if(row < n && graph[row+1][col] === 1) return true
          if(col > 0 && graph[row][col-1] === 2) return true
          return false
      }

      const graph = new Array(n+1).fill(0).map(()=>new Array(n+1).fill(0));

      build_frame.forEach(([x,y,type, command])=>{
          const row = n-y;
          const col = x;
          if(command === 1){
              if(type === 1){
                  if(checkBo(graph, row, col)) graph[row][col] = 2
              }
              else{
                  if(checkGidoong(graph, row, col)) graph[row][col] = 1
              }
          }else{
              if(type === 1){
                  if(graph[row][col] !== 2) return
                  graph[row][col] = 0;
                  if(col+1<=n && graph[row][col+1] === 2 && !checkBo(graph,row,col+1)) graph[row][col] = 2;
                  else if(col > 0 && graph[row][col-1] === 2 && !checkBo(graph,row,col-1)) graph[row][col] = 2;                
              }
              else{
                  if(graph[row][col] !== 1) return
                  graph[row][col] = 0;
                  if(row+1 <= n){
                      if(graph[row+1][col] === 2){
                          if(!checkBo(graph,row+1,col) || !checkBo(graph,row+1,col-1)){
                              graph[row][col] = 1;                        
                          }
                      }
                      else if(graph[row+1][col] === 1){
                          if(!checkGidoong(graph,row+1,col)){
                              graph[row][col] = 1;
                          }
                      }
                  }
              }    
          }
      })
      for(let y=0; y<=n; y++){
          for(let x=0; x<=n; x++){
              if(graph[y][x]) answer.push([x,n-y,graph[y][x]-1]);
          }
      }
      answer.sort((a,b)=>a[0]===b[0] ? a[1]===b[1] ? a[2]-b[2] : a[1]-b[1] : a[0]-b[0]);
      return answer;
  }
  ```