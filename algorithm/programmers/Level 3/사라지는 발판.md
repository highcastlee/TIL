# 사라지는 발판
 - [사라지는 발판](https://programmers.co.kr/learn/courses/30/lessons/92345)



### 정답 풀이

  ```javascript
  function solution(board, aloc, bloc) {
    const row_len = board.length;
    const col_len = board[0].length;
    const dir = [[1,0],[-1,0],[0,1],[0,-1]];
    let OOB = (x,y)=>{return x<0 || x>=row_len || y < 0 || y >= col_len;}
    let DFS = (curLoc,nextLoc)=>{
      if(!board[curLoc[0]][curLoc[1]]){return 0;}
      let ret = 0;
      board[curLoc[0]][curLoc[1]]=0;
      for(let i = 0; i < 4; i++){
        let nx = curLoc[0]+dir[i][0];
        let ny = curLoc[1]+dir[i][1];
        if(OOB(nx,ny)||!board[nx][ny]){continue;}
        let count = DFS(nextLoc,[nx,ny])+1;

        if(ret%2===0&&count%2===1){ret = count;}
        else if(ret%2===0&&count%2===0){ret = Math.max(ret,count);}
        else if(ret%2===1&&count%2===1){ret = Math.min(ret,count);}
      }
      board[curLoc[0]][curLoc[1]]=1;
      return ret;
    }
    return DFS(aloc,bloc);
  }
  ```


  ### 실패 풀이
    - A타입부터 플레이하며 상하좌우 이동 후, B타입에게 턴 넘김
    - 재귀로 각 케이스마다 패배 발생할 경우 기록
    - 타입별 loser와 counts를 기록

    ```javascript
    function solution(board, aloc, bloc) {
      let answer = -1;
      const dr = [0,0,-1,1];
      const dc = [1,-1,0,0];
      const rowLen = board.length;
      const colLen = board[0].length;
      const loser = {'A':0,'B':0};
      const counts = {'A':[], 'B':[]};
      function playGame(type, graph, aloc, bloc, count){
          const [cr,cc] = type === 'A' ? aloc : bloc;
          if(graph[cr][cc]===0) {
              loser[type] += 1;
              if(!counts[type].includes(count)) counts[type].push(count);
              return
          }
          let moved = false;
          for(let i=0; i<4; i++){
              const nr = cr+dr[i];
              const nc = cc+dc[i];
              if(nr<0||nc<0||nr>=rowLen||nc>=colLen||graph[nr][nc]===0) continue;
              moved = true;
              graph[cr][cc] = 0;
              playGame(type === 'A' ? 'B' : 'A', graph.map(v=>[...v]),[nr,nc], type === 'A' ? bloc : aloc, count+1);
          }
          if(!moved) {
              loser[type]+=1;
              if(!counts[type].includes(count)) counts[type].push(count);
          }
      }

      playGame('A', board.map(v=>[...v]), aloc, bloc, 0);
      return counts.B.length ? Math.max(...counts.B) : Math.min(...counts.A)
  }
  ```


