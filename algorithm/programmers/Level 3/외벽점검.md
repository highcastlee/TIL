# 외벽점검
 - [외벽점검](https://programmers.co.kr/learn/courses/30/lessons/60062#)


### 풀이
  - 순열 + 슬라이딩 윈도우
  - 원형 외벽의 순서와 방향에 대한 개념을 간편화하기 위해 n*2 길이의 배열 생성
    - i%n의 위치에 취약 지점 체크
  - 각 distance가 최대한으로 수리할 수 있는 지점을 수리하도록 copyList를 체크
    - i번째 수리하면, i+n번째로 수리되도록 작성
  - 이 때, dist의 순서는 최대 값부터 하는 것이 아닌, 무작위 순서로 진행해야 한다.
    - **dist 순열 순회**
    - 해당 순열은 중복 값 포함한 순열
  - 모든 copyList를 수리하면, answer에 사용 인원 최소값으로 갱신
  - answer가 초기값인 Infinity라면 -1, 아니면 answer 반환
  
  ```javascript
  function solution(n, weak, dist) {
      const permutations = [];
      function getPermu(arr, result){
          if(result.length >= dist.length){
              permutations.push(result)
              return
          }
          for(let i=0; i<arr.length; i++){
              result.push(arr[i]);
              const copyDist = [...arr.slice(0,i),...arr.slice(i+1)]
              getPermu(copyDist,[...result]);
              result.pop();
          }
      }
      getPermu(dist, []);
      let answer = Infinity;
      const wallList = new Array(n*2+1).fill(0).map((_,i)=>weak.includes(i%n));
      const weakList = [...weak, ...weak.map(v=>v+n)];

      for(const permu of permutations){
          const copyList = [...wallList];
          let curWeakCount = weak.length;
          for(let i=0; i<permu.length; i++){
              const curDist = permu[i];
              let maxWeakCount = 0;
              let idx = 0;
              for(let j of weakList){
                  const weakCount = copyList.slice(j,j+curDist+1).filter(v=>v).length;
                  if(maxWeakCount < weakCount){
                      maxWeakCount = Math.max(maxWeakCount, weakCount);
                      idx = j;
                  }
              }
              for(let k=idx; k<=idx+curDist; k++){
                  copyList[k] = false;
                  if(copyList[k+n]) copyList[k+n] = false;
              }
              curWeakCount -= maxWeakCount;
              if(curWeakCount < 1){
                  answer = Math.min(answer, i+1);
                  break
              }
          }
      }
      return answer === Infinity ? -1 : answer
  }
  ```