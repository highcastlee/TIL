# 셔틀버스
 - [셔틀버스](https://programmers.co.kr/learn/courses/30/lessons/17678)


### 풀이
  - 버스 시간을 9시부터 간격에 따라 key-value 형식으로 생성
  - 해당 버스 시간에 탈 수 있는 대기열 도착 크루 시각을 value waiting에 삽입
    - 버스 도착 시각 기준으로 도착 시각이 빠른 크루를 순차로 삽입(shift)
    - m 사이즈에 꽉 차면, 다음 버스 시간으로 루프
    - 버스 도착 시각이, 가장 빠른 도착 크루보다 빠르면 다음 버스 시간으로 루프
  - 결과 : busHash는 각 버스 도착 시간에 탈 수 있는 크루 시각이 기록됨
  
  - busHash의 마지막 버스 데이터에서 가능한 가장 늦은 시각 추출하기
    - 사이즈가 m이면, 도착 크루 중 (가장 늦은 시각 - 1분) 반환
    - 사이즈가 m 미만이면, 해당 버스 도착 시각 반환 (가장 늦기 떄문)

  - **문자인 버스 시각을 숫자로 변환하고 계산하고 다시 돌려야하는 번거러움**

  ```javascript
  function solution(n, t, m, timetable) {
    const formatTime = (time) => {
      const hour = Math.floor(time/60);
      const minute = time%60;
      return `${hour < 10 ? '0'+hour : hour}:${minute < 10 ? '0'+minute : minute}`        
    }

    const busTimes = new Array(n).fill(9 * 60).map((start,i)=>start+(i*t));
    const busHash = {};
    busTimes.forEach(time=>{busHash[time] = []});
    
    const arriveTimes = timetable.map(time=> {
      const [hour,min] = time.split(":").map(Number);
      return hour*60 + min
    }).sort((a,b)=>a-b);
    
    for(const [busTime, data] of Object.entries(busHash)){
      if(!arriveTimes.length) break
      while(+busTime >= arriveTimes[0] && data.length < m){
        busHash[busTime].push(arriveTimes.shift());
      }
    }
    
    const [lastBusTime, lastWaitings] = Object.entries(busHash).pop();
    if(lastWaitings.length < m) return formatTime(+lastBusTime);
    return formatTime(Math.max(...lastWaitings)-1);
  }
  ```