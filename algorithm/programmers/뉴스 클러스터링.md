
# 뉴스 클러스터링

## 구현
  - [뉴스 클러스터링](https://programmers.co.kr/learn/courses/30/lessons/17677)

  <img src="https://user-images.githubusercontent.com/62092665/138080554-176940df-37b2-4f00-be22-955616b74df4.png">

  <img src="https://user-images.githubusercontent.com/62092665/138080594-3eaa6468-a7c7-46a3-a7ed-efa4f2c38ab7.png">



### 풀이
  1. 길이가 2인 단어의 조합 중 영문이 아닌 조합 제거
  2. 대문자 치환
  3. 각 집합의 요소를 key, 개수를 value로 갖는 hash 생성
  4. 교집합 문자 종류를 나타내는 배열 생성
  5. 합집합 문자 종류를 나타내는 배열 생성
  6. 교집합 수는 numS += Math.min(hash1[key], hash2[key])
  7. 합집합 수는 numL += Math.max(hash1[key], hash2[key])
  8. 둘 다 0일 경우 return 1 * 65536
  9. 아니라면, return parseInt((numS/numL) * 65536)


```javascript
function checkEng(str){
    const regExp = /[a-zA-Z]/g;
    return regExp.test(str) ? true : false;
}

function solution(str1, str2) {    
    let [arr1, arr2] = [[],[]];
    for (let i=0; i<str1.length-1; i++){
        if(checkEng(str1[i]) && checkEng(str1[i+1])) arr1.push((str1[i]+str1[i+1]).toUpperCase())
    }
    for (let i=0; i<str2.length-1; i++){
        if(checkEng(str2[i]) && checkEng(str2[i+1])) arr2.push((str2[i]+str2[i+1]).toUpperCase())
    }
    
    let [hash1, hash2] = [{},{}]
    arr1.forEach(v=>{
        if(hash1[v]) hash1[v] += 1
        else hash1[v] = 1
    })
    arr2.forEach(v=>{
        if(hash2[v]) hash2[v] += 1
        else hash2[v] = 1
    })   

    let [smallArr,largeArr] = arr1.length < arr2.length ? [arr1,arr2] : [arr2,arr1]
    let sameArr = []
    let everyArr = []
    smallArr.forEach(s => {
        if(largeArr.includes(s) && !sameArr.includes(s)) sameArr.push(s)
        if(!everyArr.includes(s)) everyArr.push(s)
    })
    largeArr.forEach(s=>{
        if(!everyArr.includes(s)) everyArr.push(s)
    })
    
    let [numS, numL] = [0,0];
    sameArr.forEach(s=>{
        if(!hash1[s] || !hash2[s]) return
        numS += Math.min(hash1[s],hash2[s])
    })
    everyArr.forEach(s=>{
        if(hash1[s] && hash2[s]) numL += Math.max(hash1[s], hash2[s])
        else numL += hash1[s] ? hash1[s] : hash2[s]
    })
    if(numS ===0 && numL === 0) return 1* 65536
    let answer = parseInt((numS/numL) * 65536)
    return answer;
}
```




### 다른 풀이
  - 과정은 같지만, 흐름을 간결하게 정리한 코드

```javascript

function solution (str1, str2) {

  // 길이가 2인 문자마다 영문 체크 후 저장 및 전체 배열 반환
  function explode(text) {
    const result = [];
    for (let i = 0; i < text.length - 1; i++) {
      const node = text.substr(i, 2);
      if (node.match(/[A-Za-z]{2}/)) {
        result.push(node.toLowerCase());
      }
    }
    return result;
  }

  const arr1 = explode(str1);
  const arr2 = explode(str2);
  
  // 전체 합집합 중 중복 제거 Set
  const set = new Set([...arr1, ...arr2]);
  let union = 0;
  let intersection = 0;

  set.forEach(item => {
    // set의 요소마다 개수 비교
    // 최소 값은 교집합 개수 (교집합이 아니면 0이 합해지므로 상관 없음)
    // 최대 값은 합집합 개수
    const has1 = arr1.filter(x => x === item).length;
    const has2 = arr2.filter(x => x === item).length;
    union += Math.max(has1, has2);
    intersection += Math.min(has1, has2);
  })
  return union === 0 ? 65536 : Math.floor(intersection / union * 65536);
}

```


### 첨언
  - 의식의 흐름대로 구현하는 것보다 전체적인 그림과 필요한 결과 값의 본질을 알아내는 연습이 필요할 듯
  - 특히, 교집합을 따로 만들어서 개수를 체크하지 않고, 바로 길이를 비교한 후 더해도 교집합이 아니면 0이 더해진다는 것..
