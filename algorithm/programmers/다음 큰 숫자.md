
# 다음 큰 숫자
  - [다음 큰 숫자]()


### 첫 풀이
  - 2진법 변환
  - 케이스 분리
    1. 1111 와 같이 모두 1일 때
        - 10111로 맨 앞 1을 10으로 치환
    2. 1100 와 같이 앞만 모두 1일 때
        - 10001로 맨 앞 1을 10으로 치환하고, 나머지 1의 개수만큼 오른쪽부터 채움
    3. 1100110 와 같이 중간에 0과 섞인 모든 케이스
        - 1101011 와 같이 마지막 1의 앞에 있는 마지막 0을 1로 치환하고, 나머지 오른쪽 1의 개수만큼 오른쪽부터 채움
  - 10진법 변환

  ```javascript
  function solution(n) {
    function getBinary(n){
        let result = [];
        while(n > 0){
            result.unshift(n%2);
            n = Math.floor(n/2);
        }
        return result;
    }
    function getDecimal(n){
        let result = 0;
        let len = n.length;
        for(let i=0;i<len;i++){
            result += n.pop() * 2**i
        }
        return result
    }
    let num = getBinary(n);
    if(num.reduce((acc,cur)=>cur=== 1 ? acc+=1 : acc,0) === num.length){
        num.splice(0,1,1,0);
        return getDecimal(num);
    }
    let lastOneIdx = num.reduce((acc,cur,idx)=>cur === 1 ? acc = idx : acc,0);
    let lastZeroIdx = num.slice(0,lastOneIdx).reduce((acc,cur,idx)=>cur === 0 ? acc = idx : acc,0);
    let numCount = num.filter(n=>n===1).length;
    if(lastZeroIdx===0 || lastOneIdx < lastZeroIdx) {
        num.splice(0, 1, 1, 0);
        let cnt = num.reduce((acc,cur)=>cur===1 ? acc+=1 : acc, 0)-1;
        for(let i=2; i<num.length;i++) num[i] = 0;
        for(let i=num.length-cnt; i<num.length; i++) num[i] = 1
        return getDecimal(num)
    }
    else num.splice(lastZeroIdx, 1, 1);

    let cnt = 0;

    for(let i=lastZeroIdx+1; i<num.length; i++){
        if(num[i]=== 1) cnt += 1
        num[i] = 0
    }
    for(let i=num.length-(cnt-1); i<num.length; i++){
        num[i] = 1
    }

    return getDecimal(num);
  }
  ```



### 두 번째 풀이
  - toString()으로 진법 변환
  - 정규표현식으로 1의 개수를 체크하며 1씩 증가시킨 숫자와 비교
  - 개수가 같으면, 반환

  ```javascript
  function solution(n,a=n+1) {
    return n.toString(2).match(/1/g).length === a.toString(2).match(/1/g).length ? a : solution(n,a+1);
  }
  ```