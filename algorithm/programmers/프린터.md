

# 스택 / 큐


## 프린터
  - [프로그래머스 프린터 문제 바로가기](https://programmers.co.kr/learn/courses/30/lessons/42587)


<img src="https://user-images.githubusercontent.com/62092665/136915008-06fd81c0-9c3e-491f-a43b-c1912621db32.png" width="600px">


## 나의 풀이
  - 우선 순위 큐의 개념으로 첫 배열의 index와 value를 heapq = [locations, priorities]로 저장
  - 현재 큐의 첫 priorities가 우선 순위 값들의 최대일 때, 프린터 실행
  - 프린터 실행 할 때마다 인쇄 횟수인 count 증가
  - 프린터 실행 할 때마다 우선 순위 배열 다시 구함
  - 프린트 실행 한 index가 문제의 location 일 때, 종료 후 count 반환

```javascript
function solution(priorities, location) {
    let count = 0;
    let heap = priorities.map((v,i)=>[i,v])
    let subPriorities = heap.map(arr=>arr[1])
    while(true){
        if(heap[0][1] == Math.max(...subPriorities)){
            let index = heap.shift()[0];
            count++;
            if(index == location) break
            subPriorities = heap.map(arr=>arr[1])
            continue;
        }
        heap.push(heap.shift())
    }
    return count;
}
```

## 첨언
  - 배열을 [locations, priorities]로 임의로 만들어서 구현했지만, `heap[0][1]` 처럼 의미를 파악하기 힘든 코드가 발생한다는 문제가 있다.
  - 다음과 같이 객체 키를 이용한다면 코드 작성은 길어지지만, 조금 더 명확하게 의미를 파악할 수 있어 실수할 가능성을 줄일 수 있을 것이다.
  
  ```javascript
  // 배열 방법
  let heap = priorities.map((v,i)=>[i,v])
  // 결과 : [[0,2],[1,1],[2,3]...]
  // if(heap[0][1] === Math.max(...sub))...

  // 객체 방법
  let heap = priorities.map((value,index)=>{
    return {
      location : index,
      priority : value,
    }
  })
  // 결과 : 
  // [
  //  {location:0,priority:2},
  //  {location:1,priority:1},
  //  {location:2,priority:3},
  //  ...
  // ]

  // if(heap[0].priority === Math.max(...sub))...
  ```