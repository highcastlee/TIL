
# 거스름돈

## DP
  - [거스름돈](https://programmers.co.kr/learn/courses/30/lessons/12907)

  <img src="https://user-images.githubusercontent.com/62092665/137466752-b25cf7d3-08ba-4f66-836d-27f953873cbe.png">

### 내 풀이
  - 없음

### 문제 해설

#### 핵심 논리
  
만들 거스름돈 n = `5`, 화폐 종류 money = `[1,2,5]` 일 때

화폐 종류가 추가될 때마다 각 n의 경우의 수를 기록해보자.

거스름돈 n을 0부터 index로 갖는 table에 해당 경우의 수를 담고, 증가할 때마다 갱신할 것이다.

1. 화폐가 (1원) 있을 때, 거스름돈 n = 0을 만드는 경우는 1(항상 가능)
  - 나머지 n의 경우에도 1의 반복으로 만들 수 있으므로 1이다.

2. **화폐가 (1원, 2원) 있을 때, 경우의 수에 영향을 주려면 n이 적어도 추가된 화폐인 (2원)보다는 크거나 같아야한다.**
  - 경우의 수 갱신할 n은 coin 이상의 값만 해당

3. 화폐가 (1원, 2원) 있을 때, n=3인 경우의 수를 구하려면, [추가 화폐인 (2원)을 뺐을 때의 경우의 수 `table[n-2]`]와 [기존 자신의 경우의 수 `table[n]`]를 더해야한다.
  - 즉, `화폐 추가를 적용한 새로운 table[n] = table[n] + table[n-coin]`

- 아래 그림처럼 모든 배열을 만들 필요 없이 반복문으로 해결 가능하다.

  <img src="https://user-images.githubusercontent.com/62092665/137466600-077380fc-bc74-4b7f-9f46-f720e32b61ff.png" width="400px">


```javascript
function solution(n, money) {
    let dp = new Array(n+1).fill(0)
    dp[0] = 1
    money.sort()  // money 오름차순 정렬(문제 조건에 없어서 정렬을 따로 해야한다)
    for (let coin of money){
        for (let price=coin; price<=n; price++){
            dp[price] += dp[price-coin]
            
        }
    }
    return dp[n] % 1000000007
}
```