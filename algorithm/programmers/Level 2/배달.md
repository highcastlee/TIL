
# 배달 

## 플로이드 와샬 || 다익스트라 알고리즘
  - [배달](https://programmers.co.kr/learn/courses/30/lessons/12978)

  <img src="https://user-images.githubusercontent.com/62092665/138899233-b3aa9404-3690-4c5d-af73-72583cb70a11.png">

  <img src="https://user-images.githubusercontent.com/62092665/138899306-2ed31b80-b269-40fe-9148-e66a7b90e524.png">

### 내 풀이
  - 1부터 인접 노드 방문하며 노드별 최단 거리 갱신
  - weight 기준 최소힙으로 큐에 저장 및 방문
  - 다익스트라 알고리즘

```javascript
function solution(N, road, K) {
    let answer = 0;
    let minLength = new Array(N+1).fill(Infinity);
    let visited = new Array(N+1).fill(false);
    minLength[0] = 0
    minLength[1] = 0
    let hash = {}
    road.forEach(arr=>{
        if(!hash[arr[0]]) hash[arr[0]] = [{'arrived' : String(arr[1]), 'weight':arr[2]}]
        else hash[arr[0]].push({'arrived' : String(arr[1]), 'weight':arr[2]})
        if(!hash[arr[1]]) hash[arr[1]] = [{'arrived' : String(arr[0]), 'weight':arr[2]}]
        else hash[arr[1]].push({'arrived' : String(arr[0]), 'weight':arr[2]})
    })
    let heapq = [[0,'1']]
    while(heapq.length > 0){
        let [heap,x] = heapq.shift()
        visited[x] = true
        for (let obj of hash[x]){
            minLength[obj.arrived] = Math.min(minLength[x] + obj.weight ,minLength[obj.arrived])
            if(!visited[obj.arrived]) heapq.push([obj.weight, obj.arrived])
        }
        heapq.sort((x,y)=>x[0]-y[0])
    }
    answer = minLength.filter(v=>v<=K).length-1
    return answer;
}
```

### 다른 풀이
  - 플로이드 와샬
  - 각 정점마다 모든 최단 거리를 구한 후, 1에서부터의 최단거리 중 K 이하 개수 출력

```javascript
function solution(N, road, K) {
    let floyd = new Array(N+1).fill(0).map((_,i)=>new Array(N+1).fill(0).map((_,j)=>{
        if(i==j)return 0
        else return Infinity      
    }))
    road.forEach(arr=>{
        floyd[arr[0]][arr[1]] = Math.min(arr[2],floyd[arr[0]][arr[1]]);
        floyd[arr[1]][arr[0]] = Math.min(arr[2],floyd[arr[1]][arr[0]]);
    })
    
    for(let k=1; k<N+1; k++){
        for(let i=1; i<N+1; i++){
            for(let j=1; j<N+1; j++){
                floyd[i][j] = Math.min(floyd[i][j], floyd[i][k] + floyd[k][j])
            }
        }
    }
    
    return floyd[1].slice(1).filter(v=>v<=K).length
}
```

---

### 첨언
  - 내 풀이의 다익스트라에서도 가능할 것으로 예상했지만, TC 11번, TC 32번의 테스크 케이스에서 통과하지 못함 (아마 다익스트라로 풀 수 있으나 부분적인 실수가 있었을 것)


## 다익스트라 vs 플로이드 와샬

#### 개선된 다익스트라
  - 다익스트라 알고리즘은 특정 정점에서 다른 정점까지의 최단거리
  - 우선순위 큐를 통해 가까운 정점 찾는 과정 축소
  - O(E*logN)
  - 모든 정점 -> 모든 정점을 구할 경우 O(N*E*logN)
  - **가중치가 음성이면 안 된다.**

#### 플로이드 와샬
  - 모든 노드에서 모든 노드까지의 최단 경로
  - 각 단계마다 방문하지 않은 노드 중 가까운 정점 탐색할 필요 없음
  - 2차원 배열에 최단 거리 관련 정보를 저장해서 사용(DP)
  - **가중치가 음성이어도 된다.**
  - O(n^3)
  - 보통 정점의 개수가 500 이하인 경우 가능하다.
