
# 메뉴 리뉴얼

## 해시 + 조합
  - [메뉴 리뉴얼]()

  <img src="https://user-images.githubusercontent.com/62092665/137926023-df4d54e0-5ba3-4721-9454-0a03a7bfaa7d.png">

  <img src="https://user-images.githubusercontent.com/62092665/137926113-62156e06-dcb1-44c1-a98e-36bb3e3d3be3.png">


### 풀이 
  - 손님이 주문한 메뉴 중 course 개수를 기준으로 조합을 구해서 전체 손님의 course개 조합 등장 수 카운팅
    - 이 때, 손님이 주문한 메뉴를 정렬한 뒤 조합 구하는 과정 진행(TC 3번)
  - 조합 개수별 max 값 && 2개 이상인 조합의 key를 저장 후 정렬 및 반환

```javascript
function getCombination(orders, num){
    let final = {};
    function combination(str,target,n, r, count){
        if(r ===0) {
            if(final[target.join("")]) final[target.join("")] += 1
            else final[target.join("")] = 1
        }
        else if(n === 0|| n <r) return;
        else{
            target.push(str[count])
            combination(str, [...target], n-1, r-1, count+1)
            target.pop();
            combination(str, [...target], n-1, r, count+1)
        }
    }
    
    for(let s of orders){
        combination(s, [], s.length, num, 0);
    }
    return final
}

function solution(orders, course) {
    let table = []
    let answer = [];
    for(let i=0; i<orders.length; i++){
        orders[i] = orders[i].split('').sort().join('')
    }
    for(let num of course){
        table.push(getCombination(orders, num))
    }
    for(let hash of table){
        let max = Math.max(...Object.values(hash))
        for(let key in hash){
            if(hash[key] == max && max > 1) answer.push(key)
        }
    }
    return answer.sort();
}
```