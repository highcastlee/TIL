
# 후보키
  - [후보키]()




### 첫 번째 풀이
  - relation index 순서대로 추가하며 후보키가 될 수 있는지 유일성 확인
  - 후보키가 아닐 경우, 다음 index 추가하여 다시 유일성 체크
  
  - 문제점 : 후보키 조합이 더 다양하게 존재할 수 있음

```javascript
function solution(relation) {
    let len = relation.length
    let answer = 0
    
    let temp = new Array(len).fill(0).map(()=>[])
    for(let i=0; i<relation[0].length; i++){
        relation.forEach((_,j)=>{temp[j].push(relation[j][i])})
        let isCandidteKey = !temp.some((arr,idx)=>temp.some((arr2,idx2)=>{
            if(idx == idx2) return false
            if(arr2.every((v,idx3)=> v == arr[idx3])) return true
            return false
        }))
        if (isCandidteKey){   
            temp = new Array(len).fill(0).map(()=>[])
            answer+=1;
        }
    }
    return answer
}
```

### 두 번째 풀이
  - relation index 조합 + 유일성 체크
  - 최종 후보키인 result와 겹치는 index를 가진 조합은 패스
  
  - 문제점 : 최소 길이의 조합부터 확인하지만, 순서에 따라 최소성이 달라질 수 있음

```javascript
function solution(relation) {
    let len = relation.length
    let answer = 0
    let result = []
    let combinations = []
    let keys = new Array(relation[0].length).fill(0).map((_,i)=>i)
    keys.forEach(v=>getCombinations(keys, [], 0, v+1))
    
    combinations.forEach(combination=>{
        if(combination.some(v=>result.includes(v))) return
        if(!relation.some((row,idx)=>relation.some((row2,idx2)=>{
            if(idx == idx2) return false
            if(combination.every(i=>row[i]==row2[i])) return true
            return false
        }))){
            answer+=1
            result.push(...combination)
        }
    })
    
    function getCombinations(origin, arr, s, r){
        if(arr.length >= r){
            combinations.push([...arr])
            return
        }
        for(let i=s;origin.length-i>=r-s;i++){
            arr.push(origin[i])
            getCombinations(origin,arr,s+1,r)
            arr.pop()
        }
        return
    }
    return answer
}
```


### 다른 사람 풀이
  - 재귀 활용 조합 대신 비트마스크를 이용
  - 핵심 : x라는 후보키인 부분 집합을 y가 가지고 있으면 y는 최소성을 가진 후보키가 아님

```javascript
function solution(relation){
    const cols = relation[0].length;
    const check = 1<< cols;
    const answer = new Set();
    
    for(let i=1; i<check; i++){
        let temp = relation.map(x=>x.filter((_,col)=>i & (1<<col)).join(""));
        const set = new Set(temp);

        // 중복 없는 조합 answer에 추가
        if(temp.length === set.size) answer.add(i)
    }
    for(let x of answer){
        for(let y of answer){
            if(x>=y) continue;
            // x,y의 비트 AND 연산 결과가 x와 같으면, x라는 부분 집합을 y가 가지고 있다는 의미
            if((x&y) === x) answer.delete(y);
        }
    }
    return answer.size;
}
```


### 첨언
  - 조합 대신 비트 마스크를 이용할 수 있다는 것을 알게 됨.
  - 부분 집합을 다시 하나씩 확인해야하나 싶었는데, 비트 연산자 사용으로 상당히 간편하게 확인할 수 있게 됨.



