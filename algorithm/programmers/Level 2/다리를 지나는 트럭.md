
# 스택/큐

## 다리를 지나는 트럭
  - [다리를 지나는 트럭](https://programmers.co.kr/learn/courses/30/lessons/42583)

  <img src="https://user-images.githubusercontent.com/62092665/136964595-417f9de4-1b28-4a67-bc80-223f4200100e.png" width="600px">


### 내 풀이
  - bridge_length로 배열 생성하여 한 칸씩 이동하면서 조건 체크
  - 이동만 할 경우 시간 단축을 위해 필요한 시간만큼 splice() 실행
  - 테스트 케이스 1개 시간 초과 발생
    - 배열 순회 방식이라 시간이 효율적이지 못함

```javascript
function move(arr, num=0){
    let temp = [...arr]
    temp.shift();
    temp.push(num);
    return temp;
}

function sumArr(arr){
    return [...arr].reduce((acc,cur)=>acc+cur)
}

function isEmpty(arr){
    return [...arr].find(v=>v>0) == undefined
}

function solution(bridge_length, weight, truck_weights) {
    let bridge = new Array(bridge_length).fill(0)
    let time = 0
    while(true){
        if(truck_weights.length === 0 && isEmpty(bridge)) break
        let candidate = truck_weights[0] ? truck_weights[0] : 0
        if(truck_weights.length === 0 && !isEmpty(bridge)){
            let idx = bridge.findIndex(v=>v>0);
            bridge.splice(0,idx+1)
            time += idx+1
            continue
        }
        else if(sumArr(move(bridge,candidate)) > weight){
            bridge = move(bridge);
        }else{
            bridge = move(bridge, truck_weights.shift())
        }
        time++
    }
    return time
}
```



### 다른 사람 풀이
  - 큐를 만들어서 트럭마다 무게와 시간을 저장
  - queue[head].time (해당 트럭이 나올 때까지 걸리는 시간) = 다리 길이 + 트럭이 들어가기 전까지 걸린 시간
  - 조건에 맞는 상황일 때, 큐에 트럭(무게,시간)을 삽입

```javascript
function Truck(weight, time){
  this.weight = weight;
  this.time = time;
}

function solution(bridge_length, weight, truck_weights){
  let answer = 0;
  let queue = [];
  let head = 0;
  let tail = 0;

  let truck_index = 0;
  let total_weight = 0;
  let time = 0;

  // 각 트럭의 시간 = 다리 길이 + 트럭이 들어가기 전까지 걸린 시간
  queue[tail++] = new Truck(truck_weights[truck_index], bridge_length+time);
  total_weight += truck_weights[truck_index++];
  time++;

  while (head != tail){
    if(queue[head].time === time){
      total_weight -= queue[head++].weight;
    }
    // 남은 큐 길이 tail-head
    if(tail-head < bridge_length &&
      total_weight + truck_weights[truck_index] <= weight){
        queue[tail++] = new Truck(truck_weights[truck_index], bridge_length+time);
        total_weight += truck_weights[truck_index++];
     // 조건 외 이동 상황
    }else if(queue[head]){
      // 원래 현재 time이 queue[head].time과 같을 때까지 while문이 반복되어야하지만, 임의로 해당 시간으로 당겨서 단축하는 방법
      time = queue[head].time -1;
    }
    time++;
  }
  return time;
}
```





### 첨언
  - 배열을 사용할 때가 나오면 일단 만들어 보는 습관이 있는데, 문제의 요구사항을 정확히 분석해서 비효율적인 생성을 줄이는 고민이 더 필요하다.
  - 제한 조건을 잘 보고, 시간 초과나 메모리 초과가 발생하는 경우를 잘 분별하자.