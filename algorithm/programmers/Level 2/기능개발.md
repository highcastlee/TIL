
# 스택/큐

## 기능 개발



## 내 풀이
  - 큐 활용 문제
  - 개발 속도 * 필요한 작업 일 수 >= (100 - 현재 진도)
  - speeds[i] * workDay >= (100 - progresses[i])
  - 위 식을 만족하는 workDay를 0부터 찾는다.
  - workDays[] 의 앞에서부터 배포하며, pop된 값이 K라면, 한 번 배포할 때 연속된 값 중 K보다 작거나 같은 값은 함께 pop하여 count++
  - K보다 큰 값이 나오면 다시 count를 센다.
  - 각 count를 result에 모아 출력
  <br/>
  - 배열 복사하는 것과 배열이 끝날 때 처리가 조금 지저분하게 느껴진다.

```javascript
function solution(progresses, speeds) {
    let workDays = [];
    let result = [];
    for(let i=0; i<progresses.length;i++){
        let x = 0;
        while(speeds[i] * x < 100 - progresses[i]) x++;
        workDays.push(x)
    }
    while(workDays.length > 0){
        let k = workDays.shift();
        let count = 1;
        if (workDays.length <= 0) {
            result.push(count)
            break
        }
        let temp = [...workDays]
        for(let i=0;i<temp.length;i++){
            if(temp[i] <= k) {
                workDays.shift();
                count++
            }
            else{
                result.push(count)
                break
            }
            if(workDays.length === 0){
                result.push(count)
                break                
            }
        }
    }
    return result;
}
```


## 다른 사람 풀이
  - head ~ tail로 작업 index 표현
  - 배포 가능할 때까지 day 증가
  - 가능하면 head부터 체크 후 count++
    - 이 때, for문을 돌며 head 뒤의 배포 가능한 작업들도 count 된다
  - count 다 합쳐지면, answer에 추가 후, count만큼 head 증가
  - count = 0 초기화, day는 유지
  - head 가 tail이 되면 끝
  - return answer[]

```javascript
function solution(progresses, speeds){
  let answer = [];

  let head = 0;
  let tail = progresses.length;
  let day = 0;
  let count;

  while(head != tail){
    count = 0;
    day++;

    for(let i=head; i<tail; i++){
      if (progresses[i] + speeds[i] * day < 100) break;
      count++;
    }
    if(count){
      answer.push(count);
      head+=count;
    }
  }
  return answer;
}
```



### 다른 풀이 2
  - 내 풀이처럼 workDays를 구해서 days로 표현
  - i,j 활용하여 i 증가하면서 체크하고 answer는 j로 담았음

```javascript
function solution(progresses, speeds) {
    let answer = [0];
    let days = progresses.map((progress, index) => Math.ceil((100 - progress) / speeds[index]));
    let maxDay = days[0];

    for(let i = 0, j = 0; i< days.length; i++){
        if(days[i] <= maxDay) {
            answer[j] += 1;
        } else {
            maxDay = days[i];
            answer[++j] = 1;
        }
    }

    return answer;
}
```


### 첨언
  - 풀이 논리 자체는 비슷하지만, 배열을 활용하는 부분에서 원하는 결과가 무엇인지 잘 파악하고 필요한 부분만 적용할 수 있는 연습이 필요하다고 생각.
  - 반복문, 배열 관련은 다양한 메서드와 방법이 있다. 간결한 것이 더 명확하게 의미를 보여줄 수 있다.
    - 반복문을 최소로 적용하고자 고민하면 힌트가 될 수 있다.




