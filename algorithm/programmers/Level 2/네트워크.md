
# 네트워크

## DFS/BFS
  - [네트워크](https://programmers.co.kr/learn/courses/30/lessons/43162)

  <img src="https://user-images.githubusercontent.com/62092665/137167694-174e40cd-b212-48df-b592-2423e4f07af1.png">



### 내 풀이
  - n크기의 배열에 연결 상태의 index를 배열로 변환
    - `connectionL = [[1],[0],[]]`
    - index 0 일 때, 연결된 노드의 index는 1
    - index 1 일 때, 연결된 노드의 index는 0
    - index 2 일 때, 연결된 노드 없음
  
  - connectionL을 반복하며 미방문한 노드일 경우, 연결된 모든 노드 방문 처리(bfs)
  - bfs 실행할 때마다 네트워크가 카운팅 count++

```javascript
function solution(n, computers) {
    let answer = 0;
    let visited = new Array(n).fill(false);
    
    let connectionL = computers.map((connectionM,indexL) => {
        let connectionS = []; 
        connectionM.forEach((value,indexS) => {
            if(value === 1 && indexL !== indexS) connectionS.push(indexS)
        })
        return connectionS
    })
    for (let i=0; i<n; i++){
        if(!visited[i]) {
            bfs(i);
            answer++;
        }
    }
    
    function bfs(m){
        if(visited[m]) return
        let q = [];
        q.push(m)
        visited[m] = true;
        while(q.length>0){
            let index = q.shift();
            for (let i of connectionL[index]){
                if(visited[i]) continue
                visited[i] = true;
                q.push(i)
            }
        }
        return
    }
    
    return answer;
}
```



### 다른 풀이
  - computers 내 배열의 크기가 n으로 적용되어 있기 때문에 index를 활용
  - 하나의 노드에서 dfs를 실행시켜 연결된 모드 노드를 방문처리한 것이 하나의 네트워크이기 때문에 dfs 한 번 실행했을 때, return 1 처리.
    - return 값을 활용하면 count가 간략해진다.
  - computers[idx][i]가 1이면 연결된 노드를 의미하므로 해당 index인 i에서 다시 dfs 실행.


```javascript
function dfs(computers, visited, idx){
  if(visited[idx]) return 0

  visited[idx] = 1

  for (let i =0; i< computers[idx].length; i++){
    if(computers[idx][i]){
      dfs(computers,visited,i);
    }
  }
  return 1;
}

function solution(n, computers){
  let answer =0;
  let visited = new Array(n).fill(0);

  for (let i =0; i<n; i++){
    answer += dfs(computers,visited,i);
  }
  return answer;
}
```




### 첨언
  - 다른 문제와 마찬가지로 논리를 같지만, 구현 방법에서 쓸데 없이 connectionL 같은 작업을 안 하도록 잘 고민해야한다.
  - n 길이의 배열이 계속 주어지는것이 index를 쉽게 활용하라는 힌트가 될 수 있으니 잘 체크해야한다.
  - 원하는 결과가 무엇인지에 따라 dfs의 return 값을 조절할 필요가 있다.
  - 내 풀이는 connectionL을 만드는 과정에서 O(n^2)이 되기 때문에 비효율적이고, 다른 dfs 풀이는 O(N+E)이다.
  
