
# 조이스틱

## 그리디 + 완전 탐색
  -  [조이스틱](https://programmers.co.kr/learn/courses/30/lessons/42860?language=javascript)


  <img src="https://user-images.githubusercontent.com/62092665/137595340-779fd0e2-f3e9-468b-b32e-fe73abca3f02.png">



### 풀이
**핵심 포인트**
  - 정방향, 역방향 이동
  - "ABAAAAABBA" >> [정방향] 후 [역방향] 커서 이동
  - "AABAAAAAAB" >> [역방향] 후 [정방향] 커서 이동


#### 작업 1. 조이스틱 위아래 조작 Count 
  - 'A'와 name[index]의 아스키코드 차이를 좌우 방향으로 비교하여 최솟값 구함
  

#### 작업 2. 조이스틱 좌우 조작 Count
  - name 중 'A'가 아닌 위치로 이동할 때의 거리 합 중 최솟값
  - 테스트케이스
    - TC1 : "JEROEN" >> [정방향]으로만 이동
    - TC2 : "JAN" >> [역방향]으로만 이동
    - TC3 : "ABAAAAABBA" >> [정방향] 후 [역방향] 커서 이동
    - TC4 : "AABAAAABBB" >> [정방향] 후 [역방향] 커서 이동
    - TC5 : "AABAAAAAAB" >> [역방향] 후 [정방향] 커서 이동

<img src="https://blog.kakaocdn.net/dn/cYyhQG/btrbquir4qO/RAoKlsKPFzd6uuh8a1lQIK/img.jpg">

  - idx는 정방향 이동 시, 'A'가 아닌 문자의 위치
  - next_idx는 idx 이후의 문자 중 역방향 이동 시, 가장 멀리 있는 index
    - idx + 1부터 'A'가 아닐 때까지 next_idx를 증가시킨다.
  - 정방향,역방향을 왕복해야할 경우, idx와 n-next_idx 중 최소값에서 왕복하도록 한다.
    - distance = Math.min(idx, n-next_idx)
  - 전체 이동 거리는 idx가 증가하면서 계산하며 최소값으로 갱신한다.

```javascript
function solution(name) {
    let answer = 0;
    let nameArr = name.split('')

    // 상하 조이스틱 조작 횟수
    function countAlpa(s){
        return Math.min(s.charCodeAt()-'A'.charCodeAt() , 'Z'.charCodeAt()-s.charCodeAt()+1)
    }
    for (let s of nameArr){
        if(s !== 'A') answer += countAlpa(s)
    }


    // 좌우 조이스틱 조작 횟수
    let n = nameArr.length;
    let move = n-1; //정방향 최대 이동거리 n-1
    let distance;
    let nextIdx;
    
    for (let idx=0; idx<n; idx++){
        nextIdx = idx+1;
        while(nextIdx < n && nameArr[nextIdx] == 'A'){
            nextIdx += 1
        }
        distance = Math.min(idx, n-nextIdx)
        move = Math.min(move, idx + n-nextIdx + distance)
    }
    answer += move
    return answer;
}
```
