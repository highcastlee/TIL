
# 영어 끝말잇기
  - 배열 다루기
  - [영어 끝말잇기](https://programmers.co.kr/learn/courses/30/lessons/12981#)

  <img src="https://user-images.githubusercontent.com/62092665/138265988-58711b28-6e06-4116-9a65-bc1b0c304ed4.png">

  <img src="https://user-images.githubusercontent.com/62092665/138266017-79db17db-a9a6-4927-bbb6-13f92adf7048.png">


### 풀이 
  - 조건에 따라 적절한 index를 적용하는 것이 포인트
  - n 단위마다 배열을 나눈다.
  - i번째 배열이 i+1 차례
  - j번째 문자가 j+1 번호
  - index 기준으로 앞뒤 문자를 비교
    - 줄 바꿈되는 경우에 탈락자가 나온다면, 탈락 [번호, 차례]는 [1, i+2]
    - 현재 자리에 탈락자가 있다면, [j+1, i+1]
    - 다음 자리에 탈락자가 있다면, [j+2, i+1]


```javascript
function solution(n, words) {
    let arr = [];
    let temp = [];
    for (let s of words){
        if(temp.length < n) temp.push(s)
        if(temp.length === n) {
            arr.push(temp);
            temp = [];
        }
    }
    if(temp.length > 0) arr.push(temp)
    let done = [];
    
    for (let i=0; i<arr.length; i++){
        for (let j=0; j<arr[i].length; j++){
            let word1 = arr[i][j]
            if(done.includes(word1)){
                return [j+1,i+1]
            }
            done.push(word1)

            // 다음 문자가 마지막 문자일 경우 return [0,0]
            if (i == arr.length-1 && j+1 == arr[i].length){
                return [0,0]
            }
            
            // 현재 문자가 한 차례의 마지막이면, 다음 문자는 차례+1의 첫 번째 문자
            let word2 = j+1 == arr[i].length ? arr[i+1][0] : arr[i][j+1];
            if(word1[word1.length-1] !== word2[0]){
                if(j+1 == arr[i].length){
                    return [1,i+2]
                }else{
                    return [j+2,i+1]
                }
            }
        }
    }
}
```


### 다른 풀이
  - answer : words 배열 내 탈락자의 index
  - `((words.slice(0, idx).indexOf(now) !== -1 || prev !== now[0])`
    - 현재 idx 까지 문자 중, now 문자가 있으면 answer = idx
    - 이전 now 문자의 끝단어(prev)가 now[0]와 다르면 answer = idx
  - idx가 발생해서 answer에 담기면, answer는 계속 그 값을 유지
  - [번호, 차례]
    - 번호 : 탈락 index를 n으로 나눈 나머지+1 = answer%n+1
    - 차례 : 탈락 index를 n으로 나눈 몫+1 = Math.floor(answer/n+1)
    

```javascript

function solution(n, words) {
    let answer = 0;
    words.reduce((prev, now, idx) => {
        answer = answer || ((words.slice(0, idx).indexOf(now) !== -1 || prev !== now[0]) ? idx : answer);
        return now[now.length-1];
    }, "")

    return answer ? [answer%n+1, Math.floor(answer/n)+1] : [0,0];
}

```


### 첨언
  - index와 전체 길이의 관계에 대한 이해 부족
  - `answer%n+1` 같은 식은 알고보면 어렵지 않지만, 바로 떠오르지 않는다.
  - 언어를 잘 활용하는 것과 단순 구현에 집중하는 것의 차이라는 생각이 든다.