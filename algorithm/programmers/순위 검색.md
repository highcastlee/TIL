
# 이분 탐색
  - [순위 검색](https://programmers.co.kr/learn/courses/30/lessons/72412)

  <img src="https://user-images.githubusercontent.com/62092665/138468150-0f2e4490-88ee-4c60-8ba5-e6214900f5a3.png">

  <img src="https://user-images.githubusercontent.com/62092665/138468237-86850466-7ac1-4e74-aaf3-fe8dad29b0a4.png">

  <img src="https://user-images.githubusercontent.com/62092665/138468302-888ebead-b868-4ef1-952f-caff6511d746.png">


### 첫 번째 나의 풀이
  - **Test case는 모두 통과되지만, 효율성 테스트에서 시간 초과 발생**

  - 문자열 분할로 query 단어마다 info에서 누적으로 필터링 반복
  - query 조건에 맞는 info 요소만 누적으로 남겨서 최종 남은 info의 개수를 answer에 push

  - O(n^2)

```javascript
function solution(info, query) {
    var answer = [];
    let infos = info.map(str => str.split(' '))
    let querys = query.map(str => str.split(' ').filter(s=>s!=='and'))
    
    querys.forEach(arr=>{
        let candidate = infos
        let result = arr.reduce((acc,condition,idx)=>{
            candidate = candidate.filter(info=>{
                if(idx == info.length-1) {
                    return condition == '-' || Number(info[idx]) >= condition
                }
                return info[idx]==condition || condition == '-'
            })
            return candidate
        },candidate)
        answer.push(result.length);
    })
    
    return answer;
}
```


### 두 번째 나의 풀이
  - 쿼리의 조건을 거치면서 조건이 통과된 info에서 이후 조건을 탐색하는 방법으로, 조건에 맞는 index만 모아서 탐색의 범위를 줄이려고 노력함
  - 결론적으로 1번 풀이 보다 더 오래 걸림

```javascript
function solution(info, query) {
    var answer = [];
    let infos = info.map(str => str.split(' '))
    let querys = query.map(str => str.split(' ').filter(s=>s!=='and'))
    let hash = {
        java: [],
        backend: [],
        junior: [],
        pizza: [],
        python: [],
        frontend: [],
        senior: [],
        chicken: [],
        cpp: [],
    }
    infos.forEach((arr,idx)=>{
        for(let i=0; i<4; i++){
            hash[arr[i]].push(idx)
        }
    })
    let tempArr = new Array(infos.length).fill(0).map((_,i)=>i)
    querys.forEach(condition=>{
        let candidates = tempArr
        for(let i=0; i<4; i++){
            if(condition[i]=='-') continue
            if(hash[condition[i]].length===0){
                candidates = []
                break
            }
            if(candidates.length > 0){
                candidates = candidates.filter(idx=>hash[condition[i]].includes(idx))
                if(candidates.length === 0) break
                continue
            }
            candidates = candidates.concat(hash[condition[i]])
        }
        let count = candidates.reduce((acc,cur)=>{
            if(Number(infos[cur][4]) >= Number(condition[4])) return acc += 1
            else return acc
        },0)
        answer.push(count)
    })
    return answer;
}
```



### 정답 풀이
  - **조합**과 **이분 탐색**
  - 내 풀이가 하나의 query를 뽑아 여러 info 중 찾는 방법이었다면, 본 해설은 info가 통과될 수 있는 모든 예비 query(조합)들을 map으로 info의 score와 각각 매핑 시켜놓은 후, 개별 query를 key로 가지는 map에 저장되어있는 score[]에서 query 점수 이상의 개수를 찾는(이분 탐색) 방법
  1. info마다 score를 담는다.
      - 이 때, 각 위치에 '-'가 붙어도 똑같이 통과되기 때문에 모든 케이스를 조합으로 생성해서 map에 key-value로 저장한다.
      - 같은 결과의 조합에 모두 해당하는 info의 score를 담는다.
      - ex. key : 'java - junior pizza', value: [150]
      - ex. key : 'java - - pizza', value: [150]
  2. map을 정렬한 후, query마다 map에서 query를 key 값으로 갖는 score value를 찾고, 해당 점수 배열에서 query의 score를 이분 탐색으로 찾는다.
    - 특정 값 이상의 개수를 반환
  3. 각 query마다 통과하는 score의 개수를 answer[]에 저장하여 반환



```javascript
function solution(info, query) {
    var answer = [];
    let map = {};
    
    function combination(infos, score, map, start){
        let key = infos.join(""); //키 값으로 쓸거 합쳐주기 
        let value = map[key]; //값 있는지 없는지 확인해주기
        
        if(value){ //값이 있으면 push
            map[key].push(score);
        }
        else { //값이 없으면 프로퍼티 만들어줘야 됨
            map[key]=[score];
        }
        //여기서는 - 를 이용해 조합 만들어주기
        for(let i=start; i<infos.length; i++){
            let combiArr = [...infos]; //전개 연산자
            combiArr[i]='-';
            combination(combiArr, score, map, i+1);
        }
    }
    
    function binarySearch(map, key, score){
        let scoreArr = map[key];
          if (scoreArr) {
            let start = 0;
            let end = scoreArr.length;
            while (start < end) {
                let mid = Math.floor((start + end) / 2);
                
                if (scoreArr[mid] >= score) { //현재 가리키는 값이 내가 찾는 score보다 크거나 같으면
                    end = mid;
                } else if (scoreArr[mid] < score) {
                    start = mid + 1;
                }
            }
            // 정렬된 점수 배열에서 start 앞의 것들은 제거
            return scoreArr.length - start;
        } 
        else return 0
    }
    for(let i =0; i<info.length; i++){
        let infos=info[i].split(" ");
        let score=infos.pop();
        combination(infos, score, map, 0);
    }
    for(let key in map){
        map[key].sort((o1, o2) => o1 - o2);
    }
    for(let i=0; i<query.length ;i++){
        let querys = query[i].replace(/ and /g,"").split(" ");
        let score = Number(querys.pop());
        answer.push(binarySearch(map, querys.join(""), score));
    }
    return answer;
}
```



### 첨언
  - info의 범위가 1 ~ 50,000
  - query의 범위가 1 ~ 100,000
  - O(n^2)이면 시간 초과할 것으로 예상하고 이분 탐색을 시도했어야했다.
  - 추가로, 조합과 이분 탐색 개별적으로 연습이 더 필요