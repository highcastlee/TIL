
# 구명 보트

## 그리디
  - [구명보트](https://programmers.co.kr/learn/courses/30/lessons/42885)

  <img src="https://user-images.githubusercontent.com/62092665/138259321-c73ade6a-a216-43a4-aae9-58f5523566a7.png">


### 풀이
  - 정렬한 배열의 양쪽 끝에서 가장 작은 값과 가장 큰 값을 비교하며 범위를 좁혀감
  - 가장 작은 것과 더 했을 때, limit 이하가 아니라면, 해당 큰 값은 혼자 타야함
  - limit 이하라면, 두 명이 같이 탐


```javascript
function solution(people, limit) {
    people.sort()
    let BIG = 250
    let halfMax = limit/2
    let count = 0
    for(let i=0; i<people.length;i++){
        if(people[i] == BIG) continue
        if(people[i] > halfMax){
            people[i] = BIG
            count++
            continue
        }
        for(let j =people.length-1; j>=0; j--){
            if(people[j] == BIG) continue
            if(i==j) {
                people[i] = BIG
                count++
                break
            }
            if(people[i]+people[j] <= limit){
                people[i] = BIG;
                people[j] = BIG;
                count++
                break
            }else{
                people[j] = BIG;
                count++
            }
        }
    }
    return count;
}
```


### 다른 풀이
  - 보트 개수 = 전체 인원 - 두 명이 같이 타는 경우
  - 정렬된 배열 양 끝에서 시작하여 limit 이하가 되면 case 증가


```javascript
function solution(people, limit) {
    people.sort(function(a, b){return a-b});
    for(var i=0, j=people.length-1; i < j; j--) {
        if( people[i] + people[j] <= limit ) i++;
    }    
    return people.length-i;
}

```


### 첨언
  - 예외 상황에 집착하다보면, 전체적인 그림을 놓칠 수 있다.
  - 개별 케이스로 나누는 것보다 한 번에 해결할 수 있는 솔루션을 고민해보자.
    - 그러기 위해서는 문제 해결의 본질을 봐야한다.