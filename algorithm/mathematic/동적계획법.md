

# 동적계획법(Dynamic programming)
  - Memoization으로 중복 연산을 방지하며, 작은 부분 문제로 큰 문제를 해결하며 해를 도출하는 알고리즘 설계 기법
  - 부분 문제는 중복되며, 상위 문제 해결 시 재사용된다.
  - *Memoization 기법
    - 동일한 계산을 반복할 때, 이전에 계산한 값을 메모리에 저장하여 중복 연산을 방지하는 기법.

  - Top-down 방식
    - 재귀를 통해 큰 문제를 작은 문제로 나눠 해결하며 해를 찾음
    - *Memoization : 메모해놓은 값을 재사용하는 기법
      ```javascript
      function fibo_td(n, d = []){
        if (n<2) return n;
        if (d[n]) return d[n]; //Memoization
        d[n] = fibo_td(n-1) + fibo_td(n-2);
        return d[n];
      }
      console.log(fibo_td(7))
      ```
  - Bottom-up 방식
    - 반복문을 통해 작은 문제부터 차례대로 해를 찾음
    - *Tabulation : 재사용을 위해 Table에 저장하는 기법
      ```javascript
      function fibo_bu(n, d = []){
        d[0] = 0;
        d[1] = 1;

        for(let i=2; i<=n; i++){
          d[i] = d[i-1]+d[i-2];   // Tabulation
        }
        return d[n];
      }
      console.log(fibo_bu(7))
      ```


### DP 전제 조건
  - DP가 적용되기 위해서는 2가지 조건이 필요하다
    1. 부분 문제가 반복해서 발생해야한다.
    2. 부분 문제의 결과 값으로 전체 문제의 결과를 낼 수 있어야한다.
    

### 점화식
  - 수열에서 이웃하는 두 개의 항 사이에 성립하는 관계를 나타낸 관계식
  - 대표적 점화식
    - 등차 수열 : f(n) = f(n-1) + a
    - 등비 수열 : f(n) = f(n-1) * a
    - 팩토리얼 : f(n) = f(n-1) * n
    - 피보나치 수열 : f(n) = f(n-1) + f(n-2)
    

  ```javascript
  let result;

  function recursive(n){
    if (n === 1){
      return 1;
    }
    return n + recursive(n-1);
  }

  result = recursice(3);
  console.log(result);    // 6   (3 + 2 + 1)
  ```



### 피보나치 수열
  1. 반복문
      ```javascript
      function recursive(n){
        if(n < 2) return 1;
        let a = 0;
        let b = 1;
        let sum = 0;
        for (let i=2; i<n; i++ ){
          sum = a + b
          a = b;
          b = sum;
        }
        return sum;
      }
      ```

  2. 재귀
      - 메모이제이션이 없는 재귀는 반복이 매우 많을 경우, stackoverflow가 발생할 수 있다.

      ```javascript
      function recursive(n){
        if (n === 1 || n === 0){
          return n;
        }
        return recursive(n-1) + recursive(n-2);
      }

      console.log(recursice(5));    // 5
      ```

  3. Dynamic Programming (DP)
      - 일반 재귀 + 메모이제이션
      ```javascript
      function recursive(n){
        if (n === 1 || n === 0){
          return n;
        }
        if(memo[n]) return memo[n] // Memoization
        return recursive(n-1) + recursive(n-2);
      }

      console.log(recursice(5));    // 5
      ```


