
# 최단 경로(Shortest Path)
  - 가중 그래프에서 구성하는 간선 간 가중치 합이 최소가 되도록 최단 경로를 찾는 알고리즘
  - Dijkstra 알고리즘
    - 단일 최단 경로 최소 비용 산출

  - A* 알고리즘
    - 휴리스틱 방법을 사용한 탐색
  
  - Bellman-Ford 알고리즘
    - 음수 가중치를 허용한 비용 산출
  
  - Floyd-Warshall 알고리즘
    - DP 기반 고차원 기법


### 다익스트라 알고리즘
  - 그래프에서 출발점과 도착점 사이의 최단 거리를 구하는 알고리즘
  - 보통 단일 정점 간 최단 경로 산출 시 사용
  - 도로 교통망이나 OSPF 등의 네트워크 라우팅 프로토콜에 널리 이용
  - 시간 복잡도 O(e logN)

#### 구현 설명
 
다익스트라 알고리즘의 핵심은 **시작점이 고정**된 것을 전제로 한다.
dist[vertex] : 시작점에서 각 정점까지의 최단 거리
초기 값은 INFINITY이고, 시작점은 0으로 시작한다.

먼저, 시작점 A의 인접 정점인 B와 C를 방문한다고 하자.
1. B의 최단거리는 기존 dist값인 INFINITY와 (A까지의 최단거리 + A~B 거리) 중 최소 값이다. 즉, Math.min(기존 dist, dist['A']+AB거리) 가 B까지의 최단거리로 갱신된다.(C도 같은 방법)
2. 위 같은 방법으로 A와 인접한 정점을 모두 갱신했다면, 인접 정점을 하나씩 방문하여 같은 계산을 진행한다.

즉, 현재 정점을 C로 변경하여 1,2번 행위를 반복하여 이후 모든 정점 방문하며 dist를 최소값으로 갱신한다. 모든 방문이 끝나고, 최종 dist 값이 시작점으로부터의 각 정점별 최단거리이다.



```javascript
function ShortestPath() {
  this.edges = {};
}

// addVertex(): 정점 추가
ShortestPath.prototype.addVertex = function (vertex) {
  this.edges[vertex] = {};
};

// addEdge(): 간선 추가
ShortestPath.prototype.addEdge = function (srcVertex, dstVertex, weight) {
  this.edges[srcVertex][dstVertex] = weight;
};

ShortestPath.prototype._extractMin = function (queue, dist) {
  let minDistance = Number.POSITIVE_INFINITY;
  let minVertex = null;
  for (let vertex in queue) {
    if (dist[vertex] <= minDistance) {
      minDistance = dist[vertex];
      minVertex = vertex;
    }
  }
  return minVertex;
};

ShortestPath.prototype.dijkstra = function (start) {
  let queue = {};
  let dist = {};
  for (let vertex in this.edges) {
    dist[vertex] = Number.POSITIVE_INFINITY;
    queue[vertex] = this.edges[vertex];
  }
  dist[start] = 0;
  while (Object.keys(queue).length != 0) {
    let u = this._extractMin(queue, dist);
    delete queue[u];
    for (let neighbor in this.edges[u]) {
      let alt = dist[u] + this.edges[u][neighbor];
      if (alt < dist[neighbor]) dist[neighbor] = alt;
    }
  }
  for (let vertex in this.edges){
    if (dist[vertex] === Number.POSITIVE_INFINITY) delete dist[vertex];
  }
  return dist;
};
```




### 플로이드 워셜 알고리즘
  - DP를 활용하여 그래프에서 가능한 모든 정점 쌍에 대해 최단 거리를 구하는 알고리즘
  - 음의 가중치가 있어도 사용 가능하며, 많은 수의 간선으로 이루어져 있는 밀집 그래프(Dense Graph)에 적합
  - 플로이드 워셜은 시간 복잡도가 O(n^3) 이므로 모든 정점의 최단거리를 다 구해야할 경우에만 주의해서 사용하는 것이 좋다.


간단하게 말하자면, 중간 정점을 통해 건너서 목적지에 가는 경우의 거리를 포함하여 최단 거리를 계산하고 갱신하는 방법

i에서 j까지의 최단 거리
dist[i][j] = Math.min(dist[i][j], dist[i][k]+dist[k][j]);

각 i,j,k를 정점의 개수 만큼 반복한다.


```javascript
ShortestPath.prototype.floydWarshall = function () {
  let dist = {}
  for (let srcVertex in this.edges) {
    dist[srcVertex] = {}
    for (let dstVertex in this.edges) {
      if (srcVertex === dstVertex) dist[srcVertex][dstVertex] = 0
      else dist[srcVertex][dstVertex] = Number.POSITIVE_INFINITY
    }
  }
  for (let srcVertex in this.edges) {
    for (let dstVertex in this.edges[srcVertex])
      dist[srcVertex][dstVertex] = this.edges[srcVertex][dstVertex]
  }
  for (let midVertex in this.edges)
    for (let srcVertex in this.edges)
      for (let dstVertex in this.edges)
        dist[srcVertex][dstVertex] = Math.min(
          dist[srcVertex][dstVertex],
          dist[srcVertex][midVertex] + dist[midVertex][dstVertex]
        )
  for (let srcVertex in this.edges)
    for (let dstVertex in this.edges)
      if (dist[srcVertex][dstVertex] === Number.POSITIVE_INFINITY)
        delete dist[srcVertex][dstVertex]
  return dist
}
```