
# 정렬
  - 배열 내 원소들을 일정한 순서대로 열거하는 알고리즘
  - 종류
    1. 거품 정렬(Bubble Sort)
    2. 선택 정렬(Selection Sort)
    3. 삽입 정렬(Insertion Sort)
    4. 병합 정렬(Merge Sort)
    5. 퀵 정렬(Quick Sort)

  - 공동 구현
    ```javascript
    let swap = function(arr, idx_1, idx_2){
      let tmp = arr[idx_1];
      arr[idx_1] = arr[idx_2];
      arr[idx_2] = tmp;
    }
    let ascending = function(x,y){
      return x > y;
    }
    let descending = function(x,y){
      return x < y;
    }
    ```


### 거품 정렬 (Bubble Sort)

서로 인접한 두 원소를 비교하면서 정렬하는 알고리즘

평균 시간복잡도 : O(n^2)

```javascript
let bubbleSort = function(arr, compare){
  for (let i=0; i<arr.length-1; i++){
    for(let j=0; j<arr.length-i-1;j++){
      if (compare(arr[j], arr[j+1])){
        swap(arr, j, j+1);
      }
    }
  }
}
```


### 선택 정렬 (Selection Sort)

최솟값을 찾아 데이터 영역의 가장 앞으로 이동하는 방식을 반복

평균 시간복잡도 : O(n^2)

```javascript
let selectionSort = function(arr, compare){
  for (let i=0;i<arr.length; i++){
    let indexOfMin = i;
    for (let j = i+1; j<arr.length; j++){
      if(compare(arr[k], arr[j])) indexOfMin=j;
    }
    swap(arr, i, indexOfMin);
  }
}
```



### 삽입 정렬 (Insertion Sort)

**이미 정렬된** 데이터 영역과 비교하면서, 자신의 위치를 찾아 요소를 삽입하며 정렬

평균 시간복잡도 : O(n^2)

```javascript
let insertionSort = function(arr, compare){
  for (let i=1; i<arr.length; i++){
    let tmp = arr[i];
    let j;
    // i의 값을 기억해두고, 정렬 조건에 맞을 때까지 index를 i 이하로 줄이면서 비교
    for (j=i-1; j>=0; j--){
      arr[j+1] = arr[j];
      if(compare(tmp,arr[j])){
        break;
      }
    }
    // 마지막 j에서 기억해놓은 i 위치의 값 갱신
    ar[j+1] = tmp;
  }
}
```


### 병합 정렬(Merge Sort)

하나의 배열을 두 개의 균등한 크기로 분할하고, 부분 정렬하며, 이를 다시 합하면서 전체를 정렬

평균 시간 복잡도 : O(n logn)

```javascript
let mergeSort = function (arr, compare){
  if (arr.length === 1) return arr;
  let m = (arr.length /2).toFixed(0);
  let left = mergeSort(arr.slice(0,m), compare);
  let right = mergeSort(arr.slice(m), compare);

  let i =0, j=0,k=0;
  while(i < left.length && j <right.length){
    // 정렬된 배열 arr는 left,right 중 작은 값부터 담긴다
    arr[k++] = compare(left[i],right[j]) ? right[j++] : left[i++]
  }

  // i와 j가 아직 끝까지 도달하지 못했다면, left가 right보다 먼저 다 돌게한 후, right 다 넣음 
  while( i< left.length) arr[k++] = left[i++]
  while( j< left.length) arr[k++] = left[j++]

  return arr
}
```


### 퀵 정렬 (Quick Sort)

특정한 값 (pivot)을 기준으로 큰 숫자와 작은 숫자를 분할하여 정렬하는 알고리즘
  - 분할(Divide)
    - 입력 배열을 비벗을 기준으로 비균등하게 2개 부분 배열로 분할
  - 정복(Conquer)
    - 부분 배열을 정렬
  - 결합(Combine)
    - 정렬된 부분 배열들을 하나의 배열에 합병한

특징
  - 속도가 빠르다
  - 추가 메모리 공간을 필요로 하지 않는다.
  - (단점) 정렬된 리스트에서는 오히려 수행 시간이 더 많이 걸린다

퀵 정렬의 불균형 분할을 방지하기 위하여 피벗을 선택할 때, 리스트를 균등하게 분할할 수 있는 데이터를 선택하는 것이 중요하다.
  - ex. 리스트 내 중간 값

평균 시간복잡도 : O(n logn)




<img src="https://gmlwjd9405.github.io/images/algorithm-quick-sort/quick-sort2.png">

```javascript
let quickSort =function(arr, compare, s=0, e = arr.length-1){
  let start = s;
  let pivot = arr[e];

  for(let i =s; i<=e; i++){
    if(compare(pivot, arr[i])){
      swap(arr,start,i);
      start++
    }
  }
  swap(arr, start,e);

  if(start -1 > s){
    quickSort(arr, compare, s, start-1);
  }
  if(start + 1 < e){
    quickSort(arr, compare, start+1, e);
  }
}
```