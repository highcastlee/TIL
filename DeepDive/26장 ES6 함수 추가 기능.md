
# ES6 함수의 추가 기능

### ES6 이전의 함수는 모든 함수가 일반 함수로 호출 가능했고, 생성자 함수로도 호출 가능했다. 즉, callable이자 constructor이다.

### ES6 사양에서는 메서드는 메서드 축약 표현으로 정의된 함수만을 의미하고, 메서드와 화살표 함수는 인스턴스를 생성할 수 없는 non-constructor다.
  - non-constructor는 prototype을 생성하지 않는다.
  - ES6 메서드는 자신을 바인딩한 객체를 가리키는 내부 슬롯 `[[HomeObject]]` 를 갖는다.
---

### 화살표 함수와 일반 함수의 차이
  - 화살표 함수는 인스턴스를 생성할 수 없는 non-constructor다.
  - 화살표 함수에서는 중복된 매개변수 이름을 선언할 수 없다.
  - 함수 자체의 this, arguments, super, new.target 바인딩을 갖지 않는다.
    - 따라서, 화살표 함수 내부에서 this 등을 참조하면, 상위 스코프의 this 등을 참조한다.

### 화살표 함수 내부에서 this를 참조하면 상위 스코프의 this를 그대로 참조한다. 이를 lexical this라고 한다.

### 화살표 함수의 this가 일반함수와 다른 것은, 콜백 함수의 this와 외부 함수의 this가 다르기 때문에 발생하는 문제를 해결하기 위해 의도적으로 설계된 것이다.
  - 화살표 함수가 this와 관련된 모든 문제를 해결하지는 않는다.
  ```javascript
  ```


### 화살표 함수는 함수 자체의 super 바인딩을 갖지 않는다.
  - this와 마찬가지로 상위 스코프의 super를 참조한다.
  ```javascript
  class Base{
    constructor(name){
      this.name = name;
    }
    sayHi(){
      return `Hi, ${this.name}`;
    }
  }

  class Derived extends Base{
    sayHi => () => `${super.sayHi()} How are you doing?`
  }

  const derived = new Derived('Lee');
  console.log(derived.sayHi());       // Hi, Lee How are you doing?
  ```
  -  Derived 클래스의 constructor는 생략되었지만 암묵적으로 constructor가 생성된다.
  - super는 `[[HomeObject]]`를 갖는 ES6 메서드 내에서만 사용할 수 있는 키워드다.
  - sayHi 클래스 필드에 할당한 화살표 함수는 ES6 메서드는 아니지만, 함수 자체의 super 바인딩을 갖지 않기 때문에 super를 참조해도 에러가 발생하지 않는다.
  - sayHi 함수 내부의 super는 상위 스코프에 있는 constructor의 super 바인딩을 참조한다.

### 화살표 함수는 함수 자체의 arguments 바인딩을 갖지 않는다. 따라서, 화살표 함수 내부에서 arguments를 참조하면 상위 스코프의 arguments를 참조한다.
  ```javascript
  (function (){
    // 외부 함수의 arguments가 [Arguments] {'0':1,'1':2}
    const foo = () => console.log(arguments); // [Arguments] {'0':1,'1':2}
    foo(3,4);
  }(1,2));

  // arguments는 함수 내부에서 유효하므로 전역에서의 arguments는 없다.
  const foo = () => console.log(arguments);
  foo(1,2); // ReferenceError
  ```

#### 화살표 함수에서 가변 인자 함수를 구현해야 할 때는 rest 파라미터를 사용해야한다.
  ```javascript
  const sum = (...args) => args.reduce((pre,cur)=>pre+cur)
  ```

### 함수를 호출할 때 매개변수 개수만큼 인수를 전달하지 않아도 에러가 발생하지 않는 이유는?
  - 자바스크립트 엔진이 매개변수의 개수와 인수의 개수를 체크하지 않기 때문
  - 인수가 전달되지 않은 매개변수의 값은 undefined
  - ES6에서는 매개변수 기본값 사용할 수 있다.
  - 단, rest 파라미터에는 기본값 사용 불가
  - 기본값은 함수의 arguments와 length에 영향을 주지 않는다.
  ```javascript
  function sum(x=0, y=0){ return x+y; }
  sum(1,2); // x=1, y=2   -> 3
  sum(1);   // x=1, y=0   -> 1
  ```

