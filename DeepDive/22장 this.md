
# this


#### this가 필요한 이유
  - 객체 리터럴로 생성한 객체는 변수에 할당되기 직전에 평가되고, 메서드를 호출할 때는 이미 식별자에 할당된 이후다.
    - 즉, 메서드가 내부에서 해당 식별자를 참조할 수 있다.

  - 반면, 생성자 함수로 생성한 객체는 생성자 함수가 정의되고 나서 호출하는 단계에서 식별자가 정해지기 때문에 메서드 내부에서는 생성할 인스턴스를 가리키는 식별자가 무엇인지 알 수 없다.
  - 따라서, javascript에서는 자신이 속한 객체 또는 자신이 생성할 인스턴스를 가리키는 자기 참조 변수인 this를 제공한다.
  - this는 자바스크립트 엔진에 의해 암묵적으로 생성되며, 코드 어디서든 참조할 수 있다.
  - 다만, this 바인딩은 함수 호출 방식에 의해 동적으로 결정된다.

>바인딩(binding)이란, 식별자와 값을 연결하는 과정을 의미한다.

---

#### this 바인딩
  1. 전역
      - this는 전역 객체를 가리킨다.
  2. 일반 함수 내부
      - this는 전역 객체를 가리킨다.
  3. 메서드 내부
      - this는 메서드를 호출한 객체를 가리킨다.

  4. 생성자 함수 내부
      - this는 생성자 함수가 생성할 인스턴스를 가리킨다.
  
  - this는 어디서든 참조는 가능하지만, 존재 목적이 객체의 프로퍼티나 메서드를 참조하기 위한 자기 참조 변수이므로 일반 함수 내부에서 this를 사용할 이유가 없다. 따라서, strict mode에서는 this에 undefined가 바인딩 된다.


#### this 바인딩은 함수 호출 방식에 따라 동적으로 결정된다.
  - 일반 함수
  - 메서드 내부
  - 생성자 함수
  - Function.prototype.apply/call/bind
    - apply(this에 전달할 객체, 함수 인수로 넣을 배열)  // this 전달 + 함수 함수 호출
    - call(this에 전달할 객체, 인수1, 인수2,..)        // this 전달 + 함수 함수 호출
    - bind(this에 전달할 객체)                        // this만 전달




---

