
### 스코프란 무엇인가?
  - 모든 식별자는 자신이 선언된 위치에 의해 다른 코드가 식별자 자신을 참조할 수 있는 유효 범위가 결정된다. **즉, 스코프는 식별자가 유효한 범위를 말한다.**
  - 스코프란 자바스크립트 엔진이 식별자를 검색할 때 사용하는 규칙이라고도 할 수 있다.


---

### 네임 스페이스(name space)
  - 네임 스페이스란, 이름이 존재하는 공간으로, 이름들을 한 곳에 모아 충돌을 미리 방지하고 해당 이름으로 선언된 변수와 함수를 쉽게 가져다 쓸 수 있도록 만든 매커니즘

  - javascript가 하나의 네임 스페이스만 갖는다면, 모든 식별자의 이름을 유일하게 만들어야할텐데, 이는 상당히 불편하기때문에 스코프를 통해 식별자의 충돌을 방지하여 같은 이름의 변수를 사용할 수 있게 한다.
  - 즉, 스코프는 네임스페이스다.


---


### 스코프 체인이 무엇인가?
  - 외부 함수의 지역 스코프는 중첩 함수 지역 스코프의 상위 스코프로, 스코프가 위치에 따라 계층적으로 연결되어 있는 것을 의미한다. 최상위 스코프는 전역 스코프이다.
  - 스코프 체인은 변수가 참조되는 코드의 스코프에서 시작하여 상위 스코프 방향으로 선언된 변수를 검색한다.

---

### 함수 레벨 스코프
  - var 키워드로 선언된 변수는 블록 레벨 스코프가 아닌 함수 레벨 스코프다.

### 동적 스코프 vs 렉시컬 스코프
  - 동적 스코프
    - 함수를 어디서 호출했는지에 따라 함수의 상위 스코프를 결정
    - 함수가 호출되는 시점에 동적으로 상위 스코프를 판단
  - **렉시컬 스코프**
    - 함수를 어디서 정의했는지에 따라 함수의 상위 스코프를 결정
    - javascript를 비롯한 대부분의 프로그래밍 언어는 렉시컬 스코프
    - 함수가 정의되는 시점에 상위 스코프를 판단. 언제나 자신이 정의된 스코프다
    - 함수 정의가 실행되어 생성된 함수 객체는 결정된 상위 스코프를 기억한다.
      - 호출될 때마다 상위 스코프를 참조할 필요가 있기 때문 
  
  ```javascript
  var x = 1;

  function foo(){
    var x = 10;
    bar();
  }

  function bar(){
    console.log(x);
  }

  foo();  // 1
  bar();  // 1
  ```
    - bar 함수가 정의될 때 x는 전역 스코프의 x를 기억한다.
    - foo(); bar(); 모두 1이 출력된다.



---

# 14장 전역 변수의 문제점 

#### 변수의 생명주기
  - 생명 주기란, 변수의 메모리가 확보(allocate)된 시점부터 해제(release)되어 가용 메모리 풀(memory pool)에 반환되는 시점

  - 지역 변수의 생명 주기는 함수의 생명 주기와 일치한다.

  - 일반적으로 함수가 종료하면 함수가 생성한 스코프도 소멸하지만, 누군가가 스코프를 참조하고 있다면, 스코프는 해제되지 않고 생존하게 된다.
    - ex. 클로저


#### 전역 변수의 생명 주기를 설명하시오
  - 전역 변수는 var 키워드로 선언이 되면, 전역 객체의 프로퍼티가 된다. 
  - 즉, 전역 변수의 생명 주기는 전역 객체의 생명 주기와 일치하며, 브라우저에서의 전역 객체 window는 웹 페이지를 닫기 전까지 유효하다.

  - node.js 환경에서의 전역 객체는 global 이다.


#### 전역 변수의 문제점
  1. 암묵적 결합의 허용
      - 전역 변수는 모든 위치에서 참조하고 변경할 수 있으므로 의도치 않게 상태가 바뀔 수 있다는 위험이 존재
  
  2. 긴 생명 주기
      - 전역 변수는 생명 주기가 길기 때문에 메모리 리소스도 오랜 시간 소비
      - var 는 변수 중복 선언을 허용하므로 변수 이름이 중복되어 변경 가능성이 있는 시간이 길어진다. (확률이 커짐)
  
  3. 스코프 체인 상에서 종점에 존재
      - 전역 변수까지 변수를 검색하는 시간이 걸리므로 지역 변수에 비해 속도 차이가 있다.
  
  4. 네임스페이스 오염
      - 다른 파일 내에서 동일한 이름의 변수나 함수가 있을 경우, 전역 스코프를 공유하기 때문에 예상치 못한 결과를 가져올 수 있다.


#### 전역 변수의 사용을 억제하는 방법
  1. 즉시 실행 함수를 사용하면, 불필요한 선언 없이 기능을 실행시킬 수 있다.
      - 주로, 라이브러리에 사용된다.
  2. 네임스페이스 역할을 할 객체를 생성하여 전역 변수 대신 프로퍼티에 변수를 추가한다.
      - 네임 스페이스 자체가 전역변수가 되므로 그렇게 유용하지는 않다.
  
  3. 모듈 패턴
      - 모듈이란, 애플리케이션을 구성하는 개별적 요소로서 재사용 가능한 코드 조각
      - 관련이 있는 변수와 함수를 모아 즉시 실행 함수로 감싸 하나의 모듈을 만든다.
      - 캡슐화 : 객체의 상태를 나타내는 프로퍼티와 메서드를 묶는 것
        - 정보 은닉을 위해 사용되기도 한다.
  4. ES6 모듈 
      - 파일 자체의 독자적인 모듈 스코프
      - 모듈 내에서 전역 변수는 window 객체의 프로퍼티가 아니다.


---


# let, const 키워드와 블록 레벨 스코프


#### var 키워드의 중복
  - var 키워드로 선언된 변수가 중복 선언될 경우
    - `var x = 100` 처럼 초기화가 포함된 선언문이 중복으로 실행된다면, `x=100`으로 실행한다
    - `var x`처럼 초기화 없이 중복 실행된다면, 해당 실행문은 무시된다.



#### let 키워드
  - 변수 중복 선언 금지
    - 같은 스코프 내 중복 선언은 SyntaxError 발생시킴
  - 블록 레벨 스코프
    - var가 함수 레벨 스코프를 갖는 것과 달리 if, for, try 등 모든 코드 블록에서 지역 스코프를 가진다. 

  - let은 호이스팅이 발생하지 않는 것처럼 보인다.
    - 전역 스코프에서의 let은 해당 선언문의 위치에서 실행되기 전까지 선언되지 않는다.
    - 스코프의 시작 지점부터 선언문이 나올 때까지 변수를 참조할 수 없는 구간을 일시적 사각지대(Temporal Dead Zone:TDZ)라고 한다.
    - 지역 스코프에서는 호이스팅 되어 선언은 되지만, 해당 선언문의 위치 전에 참조를 한다면, TDZ에 속하기 때문에 ReferenceError를 발생시킨다.
  
  - let, const로 선언한 전역 변수는 window 전역 객체의 프로퍼티가 아니다!


#### const 키워드
  - 주로 상수 선언을 위해 사용된다. (반드시는 x)
  - const는 선언과 동시에 초기화를 해야한다.
  - 재할당 금지
  - 상수는 재할당이 금지된 변수를 말한다.
    - 상수도 값을 저장하기 위한 메모리 공간이 필요하므로 변수라고 할 수 있다.
  - 하드 코딩을 지양하고 상수를 사용하므로써 코드에 의미를 부여한다.
  - 상수는 보통 대문자 및 언더스코어를 사용하여 명명한다.

  - const를 기본으로 사용하고, let은 재할당이 필요할 때 사용한다.
    - 변수의 스코프는 최대한 좁게 만든다.
    
