
# 트리 (Tree)

<img src="https://gmlwjd9405.github.io/images/data-structure-tree/tree-terms.png" width="600px"/>

  - 그래프의 일종으로, 두 노드 사이의 하나의 간선만 연결되어 있는, 최소 연결과 계층 형태의 비선형 자료구조
  - 구조 및 용어
    - 노드 : 하나 이상의 값을 갖는 객체 단위
    - 간선 : 두 노드를 연결하는 선
    - 루트 노드(Root Node) : 부모가 없는 최상위 노드
    - 단말 노드(Leaf Node) : 자식이 없는 노드
    - 부모 노드(Parent Node) : 특정 Sub-Tree 내에서의 상위 노드
    - 자식 노드(Child Node) : 특정 Sub-Tree 내에서의 하위 노드
    - 형제 (Sibling) : 같은 부모를 갖는 자식 노드
    - 노드 크기(size) : 자신을 포함한 모든 자손 노드의 개수
    - 노드 깊이(depth) : 루트에서 특정 노드에 도달하기 위한 간선의 개수
    - 노드 레벨(level) : 트리의 특정 깊이를 가지는 노드의 집합
    - 노드 차수(Node degree) : 노드가 가진 가지의 수
    - 트리 차수(tree degree) : 트리 내 노드 중 최대 차수
    - 트리 높이 : 루트 노드에서 가장 깊숙이 있는 노드의 깊이
    
  - 특징
    - '최소 연결 트리'로 불린다.
    - 계층 모델, 방향 비순환 그래프(DAG: Directed Acyclic Graph)의 한 종류
  - 종류
    - 이진 트리, 이진 탐색 트리, AVL트리, 힙(Heap)
  


### 트리 순회
  - 트리 구조에서 각각의 노드를 정확히 한 번씩 체계적인 방법으로 방문하는 과정
  - 용어 정리
    - N : 해당 노드를 방문하는 것을 의미
    - L : 왼쪽 서브 트리로 이동하는 것을 의미
    - R : 오른쪽 서브 트리로 이동하는 것을 의미
  
  - 순회 방식
    - 전위 순회(Pre-order) : N - L - R
      - 노드 방문 -> 왼쪽 서브 트리를 전위 순회 -> 오른쪽 서브 트리를 전위 순회
    - 중위 순회(In-order) : L - N - R
    - 후위 순회(Post-order) : L - R - N
    - 층별 순회(Level-order) : 낮은 Level부터 순차적으로 순회
  

### 전위 순회
  <img src="https://user-images.githubusercontent.com/62092665/136700733-bbf5431c-1a35-4557-8237-1a67681794c9.png" width="500px"/>

  - N - L - R 방식
    1. 현재 노드를 방문한다.
    2. 왼쪽 서브 트리를 전위순회한다.
    3. 오른쪽 서브 트리를 전위 순회한다.
  - 방문 순서
    - F-B-A-D-C-E-G-I-H



### 중위 순회
  <img src="https://user-images.githubusercontent.com/62092665/136700733-bbf5431c-1a35-4557-8237-1a67681794c9.png" width="500px"/>

  - L - N - R 방식
    1. 왼쪽 서브 트리를 중위 순회한다.
    2. 현재 노드를 방문한다.
    3. 오른쪽 서브 트리를 중위 순회한다.
  - 방문 순서
    - A - B - C - D - E - F - G - H - I


### 후위 순회
  <img src="https://user-images.githubusercontent.com/62092665/136700733-bbf5431c-1a35-4557-8237-1a67681794c9.png" width="500px"/>

  - L - R - N 방식
    1. 왼쪽 서브 트리를 중위 순회한다.
    2. 오른쪽 서브 트리를 중위 순회한다.
    3. 현재 노드를 방문한다.
  - 방문 순서
    - A - C - E - D - B - H - I - H - F


### 층별 순회
  <img src="https://user-images.githubusercontent.com/62092665/136700733-bbf5431c-1a35-4557-8237-1a67681794c9.png" width="500px"/>

  - 낮은 Level부터 순차적으로 순회
    1. root 노드 방문
    2. Level 증가
    3. 왼쪽에서 오른쪽 순으로 방문
  - 방문 순서
    - F - B - G - A - D - I - C - E - H


### 트리 순회 활용 예시

##### 컴퓨터 폴더 구조에서 전체 용량 계산하기

<img src="https://img1.daumcdn.net/thumb/R1280x0/?scode=mtistory2&fname=https%3A%2F%2Fblog.kakaocdn.net%2Fdn%2FRJMNW%2FbtqFiAgutZe%2FhfmBwK4YSXkjRwXOztKZvk%2Fimg.png" width="400px">

  - 후위 순회 트리 활용
    - 내 컴퓨터 용량 = 왼쪽 전체 서브 트리 용량 + 오른쪽 전체 서브 트리 용량





## 이진 트리(Binary Tree)
  - 각 노드가 최대 두 개의 자식 노드를 가지는 트리 자료 구조
  - 활용
    - 검색과 정렬
      - 이진 탐색 트리
      - 이진 힙 구현
    - 허프만 코딩
      - 연관 분기 구조를 위한 데이터 표현에 활용
  - 종류
    - 포화 이진 트리(Perfect binary tree)
    - 완전 이진 트리(Complete binary tree)
    - 정 이진 트리(Full binary tree)
    - 편향 이진 트리(Skewed binary tree)
    - 균형 이진 트리(Balanced binary tree)


> 허프만 코딩(Huffman coding)이란?
> 텍스트 압축을 위해 널리 사용되는 방법으로, 원본 데이터에서 자주 출현하는 문자는 적은 비트의 코드로 변환하여 표현하고 출현 빈도가 낮은 문자는 많은 비트의 코드로 변환하여 표현함으로써 전체 데이터를 표현하는데 필요한 비트 수를 줄이는 방식이다.


### 포화 이진 트리(Perfect binary tree)
  - 모든 레벨의 노드가 가득 채워져 있는 트리
  - Leaf 노드를 제외한 모든 노드는 2개의 자식 노드를 보유
  - 노드의 개수 : n = 2^h - 1

  <img src="https://user-images.githubusercontent.com/62092665/136805979-5f4d7295-35d0-4d00-a6a4-8fc0ea2759b1.png" width="400px">



### 완전 이진 트리(Complete binary tree)
  - 마지막 레벨 전까지 노드가 가득 채워져있고, 마지막 레벨은 왼쪽부터 순차적으로 채워져 있는 트리
  - 배열을 사용해 효율적인 표현이 가능
  - 노드의 개수 : n < 2^h - 1
    - 포화 이진 트리보다 작다

  <img src="https://user-images.githubusercontent.com/62092665/136806306-8e6f87fa-0289-4c7a-8142-71c602abc13f.png" width="400px">


### 정 이진 트리(Full binary tree) || 적정 이진 트리(Proper binary tree)
  - 모든 노드가 0개 또는 2개의 자식 노드만 갖는 트리
  - 또는 plane 이진 트리라고도 불림
  - 노드의 개수 : n <= 2^h - 1

  <img src="https://user-images.githubusercontent.com/62092665/136806370-9978920c-a0b6-4b3d-bc6c-97e8dac46732.png" width="400px">

### 편향 이진 트리(Skewed binary tree)
  - 왼쪽 혹은 오른쪽으로 편향되게 치우쳐 있는 트리
  - 각각의 높이에 하나의 노드만 존재
  - 노드의 개수 : h
  <img src="https://user-images.githubusercontent.com/62092665/136806447-01a12b80-d59e-43be-b290-42a25f83c40b.png" width="500px">


### 균형 이진 트리(Balanced binary tree)
  - 삽입/삭제가 이루어질 때, 왼쪽 서브 트리와 오른쪽 서브 트리의 높이 차를 1 이하로 맞추는 이진 탐색 트리
  - 서브 트리 높이 차이가 항상 1 이하로 유지
  - 균형 트리 종류 : AVL트리, Red-Black 트리, B 트리, B+트리, B*트리

  <img src="https://user-images.githubusercontent.com/62092665/136806519-f0f24755-6671-4671-b7c6-1ad20011a5ac.png" width="500px">



### 이진 트리 구현

```javascript
// 큐 생성 코드 생략 (층별 순회에서 사용됨)
import { Queue } from './queue.mjs';

function Node(value) {
  this.value = value;
  this.left = null;
  this.right = null;
}

function BinaryTree() {
  this.root = null;
}

// _insertNode(): 재귀로 트리를 순회하며 노드 추가 (내부 사용)
// _ : 언더바는 네이밍 규칙으로 사용되기도 하는데, 
// 다른 언어의 private 접근자처럼 메서드 내부에서 사용되는 메서드를 정의할 때 사용한다.
BinaryTree.prototype._insertNode = function (node, value) {
  if (node === null) {
    node = new Node(value);
  } else if (value < node.value) {
    node.left = this._insertNode(node.left, value);
  } else if (value > node.value) {
    node.right = this._insertNode(node.right, value);
  }

  return node;
};

// insert(): 노드 추가
BinaryTree.prototype.insert = function (value) {
  this.root = this._insertNode(this.root, value);
};
```
- 전위 순회
```javascript
// _preOrderTraverseNode(): 전위 순회(내부 메서드)
BinaryTree.prototype._preOrderTraverseNode = function (node, callback) {
  if (node === null) {
    return;
  }
  // N - L - R 순서로 전위 순회
  callback(node);
  this._preOrderTraverseNode(node.left, callback);
  this._preOrderTraverseNode(node.right, callback);
};

BinaryTree.prototype.preOrderTraverse = function (callback) {
  this._preOrderTraverseNode(this.root, callback);
};

```
- 중위 순회
```javascript
// _inOrderTraverseNode(): 중위 순회 (내부 메서드)
BinaryTree.prototype._inOrderTraverseNode = function (node, callback) {
  if (node === null) {
    return;
  }
  // L - N - R 순서로 중위 순회
  this._inOrderTraverseNode(node.left, callback);
  callback(node);
  this._inOrderTraverseNode(node.right, callback);
};

BinaryTree.prototype.inOrderTraverse = function (callback) {
  this._inOrderTraverseNode(this.root, callback);
};
```
- 후위 순회
```javascript
// _postOrderTraverseNode(): 후위 순회 (내부 메서드)
BinaryTree.prototype._postOrderTraverseNode = function (node, callback) {
  if (node === null) {
    return;
  }

  this._postOrderTraverseNode(node.left, callback);
  this._postOrderTraverseNode(node.right, callback);
  callback(node);
};


BinaryTree.prototype.postOrderTraverse = function (callback) {
  this._postOrderTraverseNode(this.root, callback);
};
```
- 층별 순회
```javascript
BinaryTree.prototype.levelOrderTraverse = function (callback) {
  let q = new Queue();
  let node;

  q.enqueue(this.root);
  while (!q.isEmpty()) {
    node = q.dequeue();
    callback(node);
    if (node.left !== null) q.enqueue(node.left);
    if (node.right !== null) q.enqueue(node.right);
  }
};
```




---


## 이진 탐색 트리 (Binary Search Tree)
  - 현재 노드를 기준으로 왼쪽에는 작은 값, 오른쪽은 큰 값으로 **정렬**해 놓는 이진 트리 기반 자료구조
    - 이진 탐색 트리가 제공되었다면, 해당 자료구조는 정렬된 자료구조라고 생각하면 된다.

  <img src="https://user-images.githubusercontent.com/62092665/136809854-6c8bc17f-9f3f-4020-a391-a014b2ac2366.png">


### 특정 노드 삭제

#### 이진 탐색 트리의 노드 삭제 방법
#####  1. case 1) 자식이 없는 Leaf 노드 삭제
  - 해당 노드 찾아서 node = null로 삭제
  - <img src="https://media.vlpt.us/images/keum0821/post/6aacdaa1-cdf8-4366-afcb-b9495fc4e0b1/image.png" width="300px">
#####  2. case 2) 왼쪽 자식만 있는 노드 삭제
  - 삭제하고자 하는 트리의 [왼쪽 서브 트리의 최대인 가장 오른쪽 노드]를 삭제하고자 하는 트리로 옮긴다.
  - 그림에서 3인 노드를 삭제할 때, 유일한 서브 트리인 1 노드의 최대 자손 노드인 2가 3의 자리로 가게 된다.
  - <img src="https://media.vlpt.us/images/keum0821/post/b52693c9-fc5e-40df-93eb-3a41df7e353b/image.png" width="300px">
  - <img src="https://media.vlpt.us/images/keum0821/post/469e2d2e-3c32-4a0f-8c66-8f5c9b5b88df/image.png" width="300px">
  
#####  3. case 3) 오른쪽 자식만 있는 노드 삭제
  - 10 노드를 삭제할 때, 10의 오른쪽 서브 트리인 13노드의 최소인 가장 왼쪽 노드 11 노드를 10 노드의 위치로 대체한다.
    - 먼저 오른쪽 서브 트리의 최소인 11 노드를 찾고, 11의 부모인 13노드와의 연결 끊기
    - 삭제할 10 노드의 부모인 5.right = 11로 설정
    - 11.right = 13을 연결
    - 10 노드 삭제
  - 만약, 11 노드 또한 오른쪽 서브 트리를 갖고 있다면, 13노드와 연결을 끊을 때 삭제 작업을 11 노드에 대하여 똑같이 실행해준다. 즉, 노드 삭제 함수를 11노드에 대해 실행하면 노드 11의 case에 따라 삭제됨
  - <img src="https://media.vlpt.us/images/keum0821/post/4fd235f4-9d83-4b29-bd85-720ed90e82ec/image.png" width="300px">
#####  4. case 4) 왼쪽, 오른쪽 자식 모두 있는 노드에 대한 삭제
  - case 2,3 작업 중 택 1로 가능하다.
  - 단, 새로 대체할 노드에 왼쪽 자식, 오른쪽 자식을 연결해주는 작업이 추가로 필요하다.
    - 10를 삭제할 경우, 11이 대체되어 11.left = 8, 11.right = 13으로 설정해줘야한다.
  - <img src="https://media.vlpt.us/images/keum0821/post/26065e6e-2378-4805-8125-1ddea4b305ab/image.png" width="300px">



### 이진 탐색 트리 구현

```javascript
function Node(value) {
  this.value = value;
  this.left = null;
  this.right = null;
}

function BinarySearchTree() {
  this.root = null;
}


```
- 노드 추가

```javascript

// _insertNode(): 노드 추가 (내부 메서드)
BinarySearchTree.prototype._insertNode = function (node, value) {
  if (node === null) {
    node = new Node(value);
  } else if (value < node.value) {
    node.left = this._insertNode(node.left, value);
  } else if (value > node.value) {
    node.right = this._insertNode(node.right, value);
  }

  return node;
};

// insert(): 노드 추가
BinarySearchTree.prototype.insert = function (value) {
  this.root = this._insertNode(this.root, value);
};

```

- 중위 순회 

```javascript

// _inOrderTraverseNode(): 중위 순회 (내부 메서드)
BinarySearchTree.prototype._inOrderTraverseNode = function (node, callback) {
  if (node === null) {
    return;
  }

  this._inOrderTraverseNode(node.left, callback);
  callback(node);
  this._inOrderTraverseNode(node.right, callback);
};

BinarySearchTree.prototype.inOrderTraverse = function (callback) {
  this._inOrderTraverseNode(this.root, callback);
  console.log("end");
};

```
- 최소, 최대 가진 노드 탐색

```javascript

// _minNode(): 최솟값 노드 탐색
BinarySearchTree.prototype._minNode = function (node) {
  if (node === null) {
    return null;
  }

  while (node && node.left !== null) {
    node = node.left;
  }

  return node.value;
};

// _maxNode(): 최댓값 노드 탐색
BinarySearchTree.prototype._maxNode = function (node) {
  if (node === null) {
    return null;
  }

  while (node && node.right !== null) {
    node = node.right;
  }

  return node.value;
};

// min(): 최솟값 노드 탐색
BinarySearchTree.prototype.min = function () {
  return this._minNode(this.root);
};

// max(): 최댓값 노드 탐색
BinarySearchTree.prototype.max = function () {
  return this._maxNode(this.root);
};

// _searchNode(): 트리 순회하며 값을 만족하는 노드 탐색
BinarySearchTree.prototype._searchNode = function (node, value) {
  if (node === null) {
    return false;
  }

  if (node.value === value) {
    return true;
  } else if (node.value > value) {
    return this._searchNode(node.left, value);
  } else if (node.value < value) {
    return this._searchNode(node.right, value);
  }
};

// search(): value 노드 탐색
BinarySearchTree.prototype.search = function (value) {
  return this._searchNode(this.root, value);
};

```

```javascript

// _findMinNode(): 트리를 순회하며 최소 노드 탐색/반환
BinarySearchTree.prototype._findMinNode = function (node) {
  while (node && node.left !== null) {
    node = node.left;
  }

  return node;
};

// _removeNode(): 재귀로 트리를 순회하며 값을 만족하는 노드를 찾고 삭제
BinarySearchTree.prototype._removeNode = function (node, value) {
  if (node === null) {
    return null;
  }

  // 삭제할 노드를 방문했을 경우
  if (node.value === value) {
    // case 1: 삭제할 노드의 자식 노드가 모두 없을 때
    if (node.left === null && node.right === null) {
      node = null;
    }
    // case 2: 왼쪽 혹은 오른쪽 자식만 있을 때
    else if (node.left === null) {
      node = node.right;
    } else if (node.right === null) {
      node = node.left;
    }

    // case 3: 왼쪽, 오른쪽 자식 노드가 있을 때
    // 오른쪽 노드의 최소를 찾아서 현재 노드 값으로 설정
    // 오른쪽 서브 트리 중, 위에서 찾은 값을 삭제
    // 이 때, 해당 대체 값이 삭제될 때에도 _removeNode() 함수가 적용되어 case 따라 다르게 삭제됨
    else {
      let aux = this._findMinNode(node.right);
      node.value = aux.value;
      node.right = this._removeNode(node.right, aux.value);
    }
  
  // 재귀로 해당 삭제 노드까지 찾는다.
  } else if (node.value > value) {
    node.left = this._removeNode(node.left, value);
  } else if (node.value < value) {
    node.right = this._removeNode(node.right, value);
  }

  return node;
};

// remove(): 노트 삭제
BinarySearchTree.prototype.remove = function (value) {
  this.root = this._removeNode(this.root, value);
};
```