
# 트리 (Tree)

<img src="https://gmlwjd9405.github.io/images/data-structure-tree/tree-terms.png" width="600px"/>

  - 그래프의 일종으로, 두 노드 사이의 하나의 간선만 연결되어 있는, 최소 연결과 계층 형태의 비선형 자료구조
  - 구조 및 용어
    - 노드 : 하나 이상의 값을 갖는 객체 단위
    - 간선 : 두 노드를 연결하는 선
    - 루트 노드(Root Node) : 부모가 없는 최상위 노드
    - 단말 노드(Leaf Node) : 자식이 없는 노드
    - 부모 노드(Parent Node) : 특정 Sub-Tree 내에서의 상위 노드
    - 자식 노드(Child Node) : 특정 Sub-Tree 내에서의 하위 노드
    - 형제 (Sibling) : 같은 부모를 갖는 자식 노드
    - 노드 크기(size) : 자신을 포함한 모든 자손 노드의 개수
    - 노드 깊이(depth) : 루트에서 특정 노드에 도달하기 위한 간선의 개수
    - 노드 레벨(level) : 트리의 특정 깊이를 가지는 노드의 집합
    - 노드 차수(Node degree) : 노드가 가진 가지의 수
    - 트리 차수(tree degree) : 트리 내 노드 중 최대 차수
    - 트리 높이 : 루트 노드에서 가장 깊숙이 있는 노드의 깊이
    
  - 특징
    - '최소 연결 트리'로 불린다.
    - 계층 모델, 방향 비순환 그래프(DAG: Directed Acyclic Graph)의 한 종류
  - 종류
    - 이진 트리, 이진 탐색 트리, AVL트리, 힙(Heap)
  


### 트리 순회
  - 트리 구조에서 각각의 노드를 정확히 한 번씩 체계적인 방법으로 방문하는 과정
  - 용어 정리
    - N : 해당 노드를 방문하는 것을 의미
    - L : 왼쪽 서브 트리로 이동하는 것을 의미
    - R : 오른쪽 서브 트리로 이동하는 것을 의미
  
  - 순회 방식
    - 전위 순회(Pre-order) : N - L - R
      - 노드 방문 -> 왼쪽 서브 트리를 전위 순회 -> 오른쪽 서브 트리를 전위 순회
    - 중위 순회(In-order) : L - N - R
    - 후위 순회(Post-order) : L - R - N
    - 층별 순회(Level-order) : 낮은 Level부터 순차적으로 순회
  

### 전위 순회
  <img src="https://user-images.githubusercontent.com/62092665/136700733-bbf5431c-1a35-4557-8237-1a67681794c9.png" width="500px"/>

  - N - L - R 방식
    1. 현재 노드를 방문한다.
    2. 왼쪽 서브 트리를 전위순회한다.
    3. 오른쪽 서브 트리를 전위 순회한다.
  - 방문 순서
    - F-B-A-D-C-E-G-I-H



### 중위 순회
  <img src="https://user-images.githubusercontent.com/62092665/136700733-bbf5431c-1a35-4557-8237-1a67681794c9.png" width="500px"/>

  - L - N - R 방식
    1. 왼쪽 서브 트리를 중위 순회한다.
    2. 현재 노드를 방문한다.
    3. 오른쪽 서브 트리를 중위 순회한다.
  - 방문 순서
    - A - B - C - D - E - F - G - H - I


### 후위 순회
  <img src="https://user-images.githubusercontent.com/62092665/136700733-bbf5431c-1a35-4557-8237-1a67681794c9.png" width="500px"/>

  - L - R - N 방식
    1. 왼쪽 서브 트리를 중위 순회한다.
    2. 오른쪽 서브 트리를 중위 순회한다.
    3. 현재 노드를 방문한다.
  - 방문 순서
    - A - C - E - D - B - H - I - H - F


### 층별 순회
  <img src="https://user-images.githubusercontent.com/62092665/136700733-bbf5431c-1a35-4557-8237-1a67681794c9.png" width="500px"/>

  - 낮은 Level부터 순차적으로 순회
    1. root 노드 방문
    2. Level 증가
    3. 왼쪽에서 오른쪽 순으로 방문
  - 방문 순서
    - F - B - G - A - D - I - C - E - H


### 트리 순회 활용 예시

##### 컴퓨터 폴더 구조에서 전체 용량 계산하기

<img src="https://img1.daumcdn.net/thumb/R1280x0/?scode=mtistory2&fname=https%3A%2F%2Fblog.kakaocdn.net%2Fdn%2FRJMNW%2FbtqFiAgutZe%2FhfmBwK4YSXkjRwXOztKZvk%2Fimg.png" width="400px">

  - 후위 순회 트리 활용
    - 내 컴퓨터 용량 = 왼쪽 전체 서브 트리 용량 + 오른쪽 전체 서브 트리 용량





## 이진 트리(Binary Tree)
  - 각 노드가 최대 두 개의 자식 노드를 가지는 트리 자료 구조
  - 활용
    - 검색과 정렬
      - 이진 탐색 트리
      - 이진 힙 구현
    - 허프만 코딩
      - 연관 분기 구조를 위한 데이터 표현에 활용
  - 종류
    - 포화 이진 트리(Perfect binary tree)
    - 완전 이진 트리(Complete binary tree)
    - 정 이진 트리(Full binary tree)
    - 편향 이진 트리(Skewed binary tree)
    - 균형 이진 트리(Balanced binary tree)


> 허프만 코딩(Huffman coding)이란?
> 텍스트 압축을 위해 널리 사용되는 방법으로, 원본 데이터에서 자주 출현하는 문자는 적은 비트의 코드로 변환하여 표현하고 출현 빈도가 낮은 문자는 많은 비트의 코드로 변환하여 표현함으로써 전체 데이터를 표현하는데 필요한 비트 수를 줄이는 방식이다.


### 포화 이진 트리(Perfect binary tree)
  - 모든 레벨의 노드가 가득 채워져 있는 트리
  - Leaf 노드를 제외한 모든 노드는 2개의 자식 노드를 보유
  - 노드의 개수 : n = 2^h - 1

  <img src="https://user-images.githubusercontent.com/62092665/136805979-5f4d7295-35d0-4d00-a6a4-8fc0ea2759b1.png" width="400px">



### 완전 이진 트리(Complete binary tree)
  - 마지막 레벨 전까지 노드가 가득 채워져있고, 마지막 레벨은 왼쪽부터 순차적으로 채워져 있는 트리
  - 배열을 사용해 효율적인 표현이 가능
  - 노드의 개수 : n < 2^h - 1
    - 포화 이진 트리보다 작다

  <img src="https://user-images.githubusercontent.com/62092665/136806306-8e6f87fa-0289-4c7a-8142-71c602abc13f.png" width="400px">


### 정 이진 트리(Full binary tree) || 적정 이진 트리(Proper binary tree)
  - 모든 노드가 0개 또는 2개의 자식 노드만 갖는 트리
  - 또는 plane 이진 트리라고도 불림
  - 노드의 개수 : n <= 2^h - 1

  <img src="https://user-images.githubusercontent.com/62092665/136806370-9978920c-a0b6-4b3d-bc6c-97e8dac46732.png" width="400px">

### 편향 이진 트리(Skewed binary tree)
  - 왼쪽 혹은 오른쪽으로 편향되게 치우쳐 있는 트리
  - 각각의 높이에 하나의 노드만 존재
  - 노드의 개수 : h
  <img src="https://user-images.githubusercontent.com/62092665/136806447-01a12b80-d59e-43be-b290-42a25f83c40b.png" width="500px">


### 균형 이진 트리(Balanced binary tree)
  - 삽입/삭제가 이루어질 때, 왼쪽 서브 트리와 오른쪽 서브 트리의 높이 차를 1 이하로 맞추는 이진 탐색 트리
  - 서브 트리 높이 차이가 항상 1 이하로 유지
  - 균형 트리 종류 : AVL트리, Red-Black 트리, B 트리, B+트리, B*트리

  <img src="https://user-images.githubusercontent.com/62092665/136806519-f0f24755-6671-4671-b7c6-1ad20011a5ac.png" width="500px">



### 이진 트리 구현

```javascript
// 큐 생성 코드 생략 (층별 순회에서 사용됨)
import { Queue } from './queue.mjs';

function Node(value) {
  this.value = value;
  this.left = null;
  this.right = null;
}

function BinaryTree() {
  this.root = null;
}

// _insertNode(): 재귀로 트리를 순회하며 노드 추가 (내부 사용)
// _ : 언더바는 네이밍 규칙으로 사용되기도 하는데, 
// 다른 언어의 private 접근자처럼 메서드 내부에서 사용되는 메서드를 정의할 때 사용한다.
BinaryTree.prototype._insertNode = function (node, value) {
  if (node === null) {
    node = new Node(value);
  } else if (value < node.value) {
    node.left = this._insertNode(node.left, value);
  } else if (value > node.value) {
    node.right = this._insertNode(node.right, value);
  }

  return node;
};

// insert(): 노드 추가
BinaryTree.prototype.insert = function (value) {
  this.root = this._insertNode(this.root, value);
};
```
- 전위 순회
```javascript
// _preOrderTraverseNode(): 전위 순회(내부 메서드)
BinaryTree.prototype._preOrderTraverseNode = function (node, callback) {
  if (node === null) {
    return;
  }
  // N - L - R 순서로 전위 순회
  callback(node);
  this._preOrderTraverseNode(node.left, callback);
  this._preOrderTraverseNode(node.right, callback);
};

BinaryTree.prototype.preOrderTraverse = function (callback) {
  this._preOrderTraverseNode(this.root, callback);
};

```
- 중위 순회
```javascript
// _inOrderTraverseNode(): 중위 순회 (내부 메서드)
BinaryTree.prototype._inOrderTraverseNode = function (node, callback) {
  if (node === null) {
    return;
  }
  // L - N - R 순서로 중위 순회
  this._inOrderTraverseNode(node.left, callback);
  callback(node);
  this._inOrderTraverseNode(node.right, callback);
};

BinaryTree.prototype.inOrderTraverse = function (callback) {
  this._inOrderTraverseNode(this.root, callback);
};
```
- 후위 순회
```javascript
// _postOrderTraverseNode(): 후위 순회 (내부 메서드)
BinaryTree.prototype._postOrderTraverseNode = function (node, callback) {
  if (node === null) {
    return;
  }

  this._postOrderTraverseNode(node.left, callback);
  this._postOrderTraverseNode(node.right, callback);
  callback(node);
};


BinaryTree.prototype.postOrderTraverse = function (callback) {
  this._postOrderTraverseNode(this.root, callback);
};
```
- 층별 순회
```javascript
BinaryTree.prototype.levelOrderTraverse = function (callback) {
  let q = new Queue();
  let node;

  q.enqueue(this.root);
  while (!q.isEmpty()) {
    node = q.dequeue();
    callback(node);
    if (node.left !== null) q.enqueue(node.left);
    if (node.right !== null) q.enqueue(node.right);
  }
};
```




---


## 이진 탐색 트리 (Binary Search Tree)
  - 현재 노드를 기준으로 왼쪽에는 작은 값, 오른쪽은 큰 값으로 **정렬**해 놓는 이진 트리 기반 자료구조
    - 이진 탐색 트리가 제공되었다면, 해당 자료구조는 정렬된 자료구조라고 생각하면 된다.

  <img src="https://user-images.githubusercontent.com/62092665/136809854-6c8bc17f-9f3f-4020-a391-a014b2ac2366.png">


### 이진 탐색 트리 구현

```javascript
function Node(value) {
  this.value = value;
  this.left = null;
  this.right = null;
}

function BinarySearchTree() {
  this.root = null;
}


```
- 노드 추가

```javascript

// _insertNode(): 노드 추가 (내부 메서드)
BinarySearchTree.prototype._insertNode = function (node, value) {
  if (node === null) {
    node = new Node(value);
  } else if (value < node.value) {
    node.left = this._insertNode(node.left, value);
  } else if (value > node.value) {
    node.right = this._insertNode(node.right, value);
  }

  return node;
};

// insert(): 노드 추가
BinarySearchTree.prototype.insert = function (value) {
  this.root = this._insertNode(this.root, value);
};

```

- 중위 순회 

```javascript

// _inOrderTraverseNode(): 중위 순회 (내부 메서드)
BinarySearchTree.prototype._inOrderTraverseNode = function (node, callback) {
  if (node === null) {
    return;
  }

  this._inOrderTraverseNode(node.left, callback);
  callback(node);
  this._inOrderTraverseNode(node.right, callback);
};

BinarySearchTree.prototype.inOrderTraverse = function (callback) {
  this._inOrderTraverseNode(this.root, callback);
  console.log("end");
};

```
- 최소, 최대값 가진 노드 탐색

```javascript

// _minNode(): 최솟값 노드 탐색
BinarySearchTree.prototype._minNode = function (node) {
  if (node === null) {
    return null;
  }

  while (node && node.left !== null) {
    node = node.left;
  }

  return node.value;
};

// _maxNode(): 최대값 노드 탐색
BinarySearchTree.prototype._maxNode = function (node) {
  if (node === null) {
    return null;
  }

  while (node && node.right !== null) {
    node = node.right;
  }

  return node.value;
};

// min(): 최솟값 노드 탐색
BinarySearchTree.prototype.min = function () {
  return this._minNode(this.root);
};

// max(): 최댓값 노드 탐색
BinarySearchTree.prototype.max = function () {
  return this._maxNode(this.root);
};

// _searchNode(): 트리 순회하며 값을 만족하는 노드 탐색
BinarySearchTree.prototype._searchNode = function (node, value) {
  if (node === null) {
    return false;
  }

  if (node.value === value) {
    return true;
  } else if (node.value > value) {
    return this._searchNode(node.left, value);
  } else if (node.value < value) {
    return this._searchNode(node.right, value);
  }
};

// search(): value 노드 탐색
BinarySearchTree.prototype.search = function (value) {
  return this._searchNode(this.root, value);
};

```
- 특정 노드 삭제


```javascript

// _findMimNode(): 반복문으로 트리를 순회하며 최솟값을 보유한 노드 탐색/반환
BinarySearchTree.prototype._findMinNode = function (node) {
  while (node && node.left !== null) {
    node = node.left;
  }

  return node;
};

// _removeNode(): 재귀로 트리를 순회하며 값을 만족하는 노드를 찾고 삭제
BinarySearchTree.prototype._removeNode = function (node, value) {
  if (node === null) {
    return null;
  }

  if (node.value === value) {
    // case 1: 0 child node (leaf node)
    if (node.left === null && node.right === null) {
      node = null;
    }
    // case 2: 1 child node
    else if (node.left === null) {
      node = node.right;
    } else if (node.right === null) {
      node = node.left;
    }

    // case 3: 2 child node
    else {
      let aux = this._findMinNode(node.right);
      node.value = aux.value;
      node.right = this._removeNode(node.right, aux.value);
    }
  } else if (node.value > value) {
    node.left = this._removeNode(node.left, value);
  } else if (node.value < value) {
    node.right = this._removeNode(node.right, value);
  }

  return node;
};

// remove(): 노트 삭제
BinarySearchTree.prototype.remove = function (value) {
  this.root = this._removeNode(this.root, value);
};
```